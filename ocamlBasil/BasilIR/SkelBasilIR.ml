(* File generated by the BNF Converter (bnfc 2.9.5). *)

module SkelBasilIR = struct

open AbsBasilIR

type result = string

let failure x = failwith "Undefined case." (* x discarded *)

let rec transBVTYPE (x : bVTYPE) : result = match x with
    BVTYPE string -> failure x


and transBIdent (x : bIdent) : result = match x with
    BIdent string -> failure x


and transBeginList (x : beginList) : result = match x with
    BeginList string -> failure x


and transEndList (x : endList) : result = match x with
    EndList string -> failure x


and transBeginRec (x : beginRec) : result = match x with
    BeginRec string -> failure x


and transEndRec (x : endRec) : result = match x with
    EndRec string -> failure x


and transStr (x : str) : result = match x with
    Str string -> failure x


and transIntegerHex (x : integerHex) : result = match x with
    IntegerHex string -> failure x


and transBitvectorHex (x : bitvectorHex) : result = match x with
    BitvectorHex string -> failure x


and transProgram (x : program) : result = match x with
    Prog declarations -> failure x


and transDeclaration (x : declaration) : result = match x with
    LetDecl (bident, mexpr) -> failure x
  | MemDecl (bident, type') -> failure x
  | VarDecl (bident, type') -> failure x
  | Procedure (bident, paramss0, paramss, procdef) -> failure x


and transMExpr (x : mExpr) : result = match x with
    MSym bident -> failure x
  | BlockM block -> failure x


and transIntType (x : intType) : result = match x with
    IntT  -> failure x


and transBoolType (x : boolType) : result = match x with
    BoolT  -> failure x


and transMapType (x : mapType) : result = match x with
    MapT (type'0, beginlist, type', endlist) -> failure x


and transBVType (x : bVType) : result = match x with
    BVT bvtype -> failure x


and transType (x : typeT) : result = match x with
    TypeIntType inttype -> failure x
  | TypeBoolType booltype -> failure x
  | TypeMapType maptype -> failure x
  | TypeBVType bvtype -> failure x


and transIntVal (x : intVal) : result = match x with
    HexInt integerhex -> failure x
  | DecInt integer -> failure x


and transAddrAttr (x : addrAttr) : result = match x with
    AddrAttrSome (beginrec, intval, endrec) -> failure x
  | AddrAttrNone  -> failure x
  | AddrAttrEmpty (beginrec, endrec) -> failure x


and transEndian (x : endian) : result = match x with
    LittleEndian  -> failure x
  | BigEndian  -> failure x


and transStatement (x : statement) : result = match x with
    Assign (lvar, expr) -> failure x
  | SLoad (lvar, endian, bident, expr, intval) -> failure x
  | SStore (endian, bident, expr0, expr, intval) -> failure x
  | DirectCall (calllvars, bident, exprs) -> failure x
  | IndirectCall expr -> failure x
  | Assume expr -> failure x
  | Assert expr -> failure x


and transCallLVars (x : callLVars) : result = match x with
    NoOutParams  -> failure x
  | LocalVars lvars -> failure x
  | ListOutParams lvars -> failure x


and transJump (x : jump) : result = match x with
    GoTo bidents -> failure x
  | Unreachable  -> failure x
  | Return exprs -> failure x


and transLVar (x : lVar) : result = match x with
    LVarDef (bident, type') -> failure x
  | GlobalLVar (bident, type') -> failure x


and transBlock (x : block) : result = match x with
    B (bident, addrattr, beginlist, statements, jump, endlist) -> failure x


and transPEntry (x : pEntry) : result = match x with
    EntrySome str -> failure x
  | EntryNone  -> failure x


and transPAddress (x : pAddress) : result = match x with
    AddrSome intval -> failure x
  | AddrNone  -> failure x


and transInternalBlocks (x : internalBlocks) : result = match x with
    BSome (beginlist, blocks, endlist) -> failure x
  | BNone  -> failure x


and transProcDef (x : procDef) : result = match x with
    PD (beginrec, str, paddress, pentry, internalblocks, endrec) -> failure x


and transParams (x : params) : result = match x with
    Param (bident, type') -> failure x


and transExpr (x : expr) : result = match x with
    RVar (bident, type') -> failure x
  | BinaryExpr (binop, expr0, expr) -> failure x
  | UnaryExpr (unop, expr) -> failure x
  | ZeroExtend (intval, expr) -> failure x
  | SignExtend (intval, expr) -> failure x
  | Extract (intval0, intval, expr) -> failure x
  | Concat (expr0, expr) -> failure x
  | BVLiteral (intval, bvtype) -> failure x
  | IntLiteral intval -> failure x
  | TrueLiteral  -> failure x
  | FalseLiteral  -> failure x


and transBinOp (x : binOp) : result = match x with
    BinOpBVBinOp bvbinop -> failure x
  | BinOpBVLogicalBinOp bvlogicalbinop -> failure x
  | BinOpBoolBinOp boolbinop -> failure x
  | BinOpIntLogicalBinOp intlogicalbinop -> failure x
  | BinOpIntBinOp intbinop -> failure x


and transUnOp (x : unOp) : result = match x with
    UnOpBVUnOp bvunop -> failure x
  | UnOp_boolnot  -> failure x
  | UnOp_intneg  -> failure x


and transBVUnOp (x : bVUnOp) : result = match x with
    BVUnOp_bvnot  -> failure x
  | BVUnOp_bvneg  -> failure x


and transBVBinOp (x : bVBinOp) : result = match x with
    BVBinOp_bvand  -> failure x
  | BVBinOp_bvor  -> failure x
  | BVBinOp_bvadd  -> failure x
  | BVBinOp_bvmul  -> failure x
  | BVBinOp_bvudiv  -> failure x
  | BVBinOp_bvurem  -> failure x
  | BVBinOp_bvshl  -> failure x
  | BVBinOp_bvlshr  -> failure x
  | BVBinOp_bvult  -> failure x
  | BVBinOp_bvnand  -> failure x
  | BVBinOp_bvnor  -> failure x
  | BVBinOp_bvxor  -> failure x
  | BVBinOp_bvxnor  -> failure x
  | BVBinOp_bvcomp  -> failure x
  | BVBinOp_bvsub  -> failure x
  | BVBinOp_bvsdiv  -> failure x
  | BVBinOp_bvsrem  -> failure x
  | BVBinOp_bvsmod  -> failure x
  | BVBinOp_bvashr  -> failure x


and transBVLogicalBinOp (x : bVLogicalBinOp) : result = match x with
    BVLogicalBinOp_bvule  -> failure x
  | BVLogicalBinOp_bvugt  -> failure x
  | BVLogicalBinOp_bvuge  -> failure x
  | BVLogicalBinOp_bvslt  -> failure x
  | BVLogicalBinOp_bvsle  -> failure x
  | BVLogicalBinOp_bvsgt  -> failure x
  | BVLogicalBinOp_bvsge  -> failure x
  | BVLogicalBinOp_bveq  -> failure x
  | BVLogicalBinOp_bvneq  -> failure x


and transIntBinOp (x : intBinOp) : result = match x with
    IntBinOp_intadd  -> failure x
  | IntBinOp_intmul  -> failure x
  | IntBinOp_intsub  -> failure x
  | IntBinOp_intdiv  -> failure x
  | IntBinOp_intmod  -> failure x


and transIntLogicalBinOp (x : intLogicalBinOp) : result = match x with
    IntLogicalBinOp_inteq  -> failure x
  | IntLogicalBinOp_intneq  -> failure x
  | IntLogicalBinOp_intlt  -> failure x
  | IntLogicalBinOp_intle  -> failure x
  | IntLogicalBinOp_intgt  -> failure x
  | IntLogicalBinOp_intge  -> failure x


and transBoolBinOp (x : boolBinOp) : result = match x with
    BoolBinOp_booleq  -> failure x
  | BoolBinOp_boolneq  -> failure x
  | BoolBinOp_booland  -> failure x
  | BoolBinOp_boolor  -> failure x
  | BoolBinOp_boolimplies  -> failure x
  | BoolBinOp_boolequiv  -> failure x



end

(* File generated by the BNF Converter (bnfc 2.9.5). *)

module SkelBasilIR = struct

open AbsBasilIR

type result = string

let failure x = failwith "Undefined case." (* x discarded *)

let rec transBVTYPE (x : bVTYPE) : result = match x with
    BVTYPE string -> failure x


and transBIdent (x : bIdent) : result = match x with
    BIdent string -> failure x


and transStr (x : str) : result = match x with
    Str string -> failure x


and transIntegerHex (x : integerHex) : result = match x with
    IntegerHex string -> failure x


and transProgram (x : program) : result = match x with
    Prog declarations -> failure x


and transDeclaration (x : declaration) : result = match x with
    LetDecl (bident, mexpr) -> failure x
  | MemDecl (bident, type') -> failure x
  | VarDecl (bident, type') -> failure x
  | Procedure (bident, paramss0, paramss, procdef) -> failure x


and transMExpr (x : mExpr) : result = match x with
    MSym bident -> failure x
  | BlockM block -> failure x


and transIntType (x : intType) : result = match x with
    IntT  -> failure x


and transBoolType (x : boolType) : result = match x with
    BoolT  -> failure x


and transMapType (x : mapType) : result = match x with
    MapT (type'0, type') -> failure x


and transBVType (x : bVType) : result = match x with
    ShortBVT bvtype -> failure x
  | BitvectorType intlit -> failure x


and transType (x : typeT) : result = match x with
    TypeIntType inttype -> failure x
  | TypeBoolType booltype -> failure x
  | TypeMapType maptype -> failure x
  | TypeBVType bvtype -> failure x


and transIntLit (x : intLit) : result = match x with
    HexInt integerhex -> failure x
  | DecInt integer -> failure x


and transAddrAttr (x : addrAttr) : result = match x with
    AddrAttrSome intlit -> failure x
  | AddrAttrNone  -> failure x
  | AddrAttrEmpty  -> failure x


and transEndian (x : endian) : result = match x with
    LittleEndian  -> failure x
  | BigEndian  -> failure x


and transStatement (x : statement) : result = match x with
    AssignStmt assign -> failure x
  | SLoad (bvlvar, endian, bident, bvexpr, intlit) -> failure x
  | SStore (endian, bident, expr, bvexpr, intlit) -> failure x
  | DirectCall (bident, exprs) -> failure x
  | DirectCallReturnLocal (lvars, bident, exprs) -> failure x
  | DirectCallReturn (lvars, bident, exprs) -> failure x
  | IndirectCall expr -> failure x
  | Assume expr -> failure x
  | Assert expr -> failure x


and transAssign (x : assign) : result = match x with
    IntAssign (intlvar, intexpr) -> failure x
  | BVAssign (bvlvar, bvexpr) -> failure x
  | BoolAssign (boollvar, logexpr) -> failure x


and transJump (x : jump) : result = match x with
    GoTo bidents -> failure x
  | Unreachable  -> failure x
  | Return exprs -> failure x


and transLVar (x : lVar) : result = match x with
    LVarIntLVar intlvar -> failure x
  | LVarBVLVar bvlvar -> failure x
  | LVarBoolLVar boollvar -> failure x


and transBVLVar (x : bVLVar) : result = match x with
    LocalBVLVar (bident, bvtype) -> failure x
  | GlobalBVLVar (bident, bvtype) -> failure x


and transIntLVar (x : intLVar) : result = match x with
    LocalIntLVar (bident, inttype) -> failure x
  | GlobalIntLVar (bident, inttype) -> failure x


and transBoolLVar (x : boolLVar) : result = match x with
    LocalBoolLVar (bident, booltype) -> failure x
  | GlobalBoolLVar (bident, booltype) -> failure x


and transBlock (x : block) : result = match x with
    B (bident, addrattr, statements, jump) -> failure x


and transPEntry (x : pEntry) : result = match x with
    EntrySome block -> failure x
  | EntryNone  -> failure x


and transPExit (x : pExit) : result = match x with
    ESome block -> failure x
  | ENone  -> failure x


and transPAddress (x : pAddress) : result = match x with
    AddrSome intlit -> failure x
  | AddrNone  -> failure x


and transInternalBlocks (x : internalBlocks) : result = match x with
    BSome blocks -> failure x
  | BNone  -> failure x


and transProcDef (x : procDef) : result = match x with
    PD (str, paddress, pentry, pexit, internalblocks) -> failure x


and transParams (x : params) : result = match x with
    Param (bident, type') -> failure x


and transExpr (x : expr) : result = match x with
    BitvectorExpr bvexpr -> failure x
  | LogicalExpr logexpr -> failure x
  | IntegerExpr intexpr -> failure x


and transBVExpr (x : bVExpr) : result = match x with
    BVBinary (bvbinop, bvexpr0, bvexpr) -> failure x
  | BVUnary (bvunop, bvexpr) -> failure x
  | ZeroExtend (intlit, bvexpr) -> failure x
  | SignExtend (intlit, bvexpr) -> failure x
  | Extract (intlit0, intlit, bvexpr) -> failure x
  | Concat (bvexpr0, bvexpr) -> failure x
  | BVLiteral (intlit, bvtype) -> failure x
  | RBVVar bvrvar -> failure x


and transIntExpr (x : intExpr) : result = match x with
    IntLiteral intlit -> failure x
  | RIntVar intrvar -> failure x
  | IntBinary (intbinop, intexpr0, intexpr) -> failure x
  | IntNeg intexpr -> failure x


and transLogExpr (x : logExpr) : result = match x with
    BVLogBinary (bvlogicalbinop, bvexpr0, bvexpr) -> failure x
  | RLogVar boolrvar -> failure x
  | BoolLit boolliteral -> failure x
  | IntLogBinary (intlogicalbinop, intexpr0, intexpr) -> failure x
  | BoolLogBinOp (boolbinop, logexpr0, logexpr) -> failure x
  | BoolNot logexpr -> failure x


and transIntRVar (x : intRVar) : result = match x with
    IRV (bident, inttype) -> failure x


and transBVRVar (x : bVRVar) : result = match x with
    BVRV (bident, bvtype) -> failure x


and transBoolRVar (x : boolRVar) : result = match x with
    BRV (bident, booltype) -> failure x


and transBoolLiteral (x : boolLiteral) : result = match x with
    BoolLiteral_true  -> failure x
  | BoolLiteral_false  -> failure x


and transBVUnOp (x : bVUnOp) : result = match x with
    BVUnOp_bvnot  -> failure x
  | BVUnOp_bvneg  -> failure x


and transBVBinOp (x : bVBinOp) : result = match x with
    BVBinOp_bvand  -> failure x
  | BVBinOp_bvor  -> failure x
  | BVBinOp_bvadd  -> failure x
  | BVBinOp_bvmul  -> failure x
  | BVBinOp_bvudiv  -> failure x
  | BVBinOp_bvurem  -> failure x
  | BVBinOp_bvshl  -> failure x
  | BVBinOp_bvlshr  -> failure x
  | BVBinOp_bvnand  -> failure x
  | BVBinOp_bvnor  -> failure x
  | BVBinOp_bvxor  -> failure x
  | BVBinOp_bvxnor  -> failure x
  | BVBinOp_bvcomp  -> failure x
  | BVBinOp_bvsub  -> failure x
  | BVBinOp_bvsdiv  -> failure x
  | BVBinOp_bvsrem  -> failure x
  | BVBinOp_bvsmod  -> failure x
  | BVBinOp_bvashr  -> failure x


and transBVLogicalBinOp (x : bVLogicalBinOp) : result = match x with
    BVLogicalBinOp_bvule  -> failure x
  | BVLogicalBinOp_bvugt  -> failure x
  | BVLogicalBinOp_bvuge  -> failure x
  | BVLogicalBinOp_bvslt  -> failure x
  | BVLogicalBinOp_bvsle  -> failure x
  | BVLogicalBinOp_bvsgt  -> failure x
  | BVLogicalBinOp_bvsge  -> failure x
  | BVLogicalBinOp_bveq  -> failure x
  | BVLogicalBinOp_bvneq  -> failure x
  | BVLogicalBinOp_bvult  -> failure x


and transIntBinOp (x : intBinOp) : result = match x with
    IntBinOp_intadd  -> failure x
  | IntBinOp_intmul  -> failure x
  | IntBinOp_intsub  -> failure x
  | IntBinOp_intdiv  -> failure x
  | IntBinOp_intmod  -> failure x


and transIntLogicalBinOp (x : intLogicalBinOp) : result = match x with
    IntLogicalBinOp_inteq  -> failure x
  | IntLogicalBinOp_intneq  -> failure x
  | IntLogicalBinOp_intlt  -> failure x
  | IntLogicalBinOp_intle  -> failure x
  | IntLogicalBinOp_intgt  -> failure x
  | IntLogicalBinOp_intge  -> failure x


and transBoolBinOp (x : boolBinOp) : result = match x with
    BoolBinOp_booleq  -> failure x
  | BoolBinOp_boolneq  -> failure x
  | BoolBinOp_booland  -> failure x
  | BoolBinOp_boolor  -> failure x
  | BoolBinOp_boolimplies  -> failure x
  | BoolBinOp_boolequiv  -> failure x



end

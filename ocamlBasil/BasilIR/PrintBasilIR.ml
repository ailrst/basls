(* File generated by the BNF Converter (bnfc 2.9.5). *)

(* pretty-printer *)

open Printf

(* We use string buffers for efficient string concatenation.
   A document takes a buffer and an indentation, has side effects on the buffer
   and returns a new indentation. The indentation argument indicates the level
   of indentation to be used if a new line has to be started (because of what is
   already in the buffer) *)
type doc = Buffer.t -> int -> int

let rec printTree (printer : int -> 'a -> doc) (tree : 'a) : string =
    let buffer_init_size = 64 (* you may want to change this *)
    in let buffer = Buffer.create buffer_init_size
    in
        let _ = printer 0 tree buffer 0 in (* discard return value *)
        Buffer.contents buffer

let indent_width = 2

let spaces (i: int) : string = if i > 0 then String.make i ' ' else ""
let indent (i: int) : string = "\n" ^ spaces i

(* To avoid dependency on package extlib, which has
   Extlib.ExtChar.Char.is_whitespace, we employ the following awkward
   way to check a character for whitespace.
   Note: String.trim exists in the core libraries since Ocaml 4.00. *)
let isWhiteSpace (c: char) : bool = String.trim (String.make 1 c) = ""

(* this render function is written for C-style languages, you may want to change it *)
let render (s : string) : doc = fun buf i ->
    (* invariant: last char of the buffer is never whitespace *)
    let n = Buffer.length buf in
    let last = if n = 0 then None else Some (Buffer.nth buf (n-1)) in
    let newindent = match s with
        "{" -> i + indent_width
      | "}" -> i - indent_width
      | _ -> i in
    let whitespace = match last with
        None -> ""
      | Some '}' -> (match s with
            ";" -> ""
          | _ -> indent newindent)
      | (Some '{') | (Some ';') -> if s = "}" then indent newindent else indent i
      | (Some '[') | (Some '(') -> ""
      | Some c -> if isWhiteSpace c then "" else (match s with
             ";" | "," | ")" | "]" -> ""
           | "{" -> indent i
           | "}" -> indent newindent
           | _ -> if String.trim s = "" then "" else " ") in
    Buffer.add_string buf whitespace;
    Buffer.add_string buf s;
    newindent

let emptyDoc : doc = fun buf i -> i

let concatD (ds : doc list) : doc = fun buf i ->
    List.fold_left (fun accIndent elemDoc -> elemDoc buf accIndent) (emptyDoc buf i) ds

let parenth (d:doc) : doc = concatD [render "("; d; render ")"]

let prPrec (i:int) (j:int) (d:doc) : doc = if j<i then parenth d else d


let prtChar (_:int) (c:char) : doc = render ("'" ^ Char.escaped c ^ "'")



let prtInt (_:int) (i:int) : doc = render (string_of_int i)



let prtFloat (_:int) (f:float) : doc = render (sprintf "%.15g" f)



let prtString (_:int) (s:string) : doc = render ("\"" ^ String.escaped s ^ "\"")




let prtBVTYPE _ (AbsBasilIR.BVTYPE (_,i)) : doc = render i


let prtINTTYPE _ (AbsBasilIR.INTTYPE (_,i)) : doc = render i


let prtBOOLTYPE _ (AbsBasilIR.BOOLTYPE (_,i)) : doc = render i


let prtBIdent _ (AbsBasilIR.BIdent (_,i)) : doc = render i


let prtLocalIdent _ (AbsBasilIR.LocalIdent (_,i)) : doc = render i


let prtGlobalIdent _ (AbsBasilIR.GlobalIdent (_,i)) : doc = render i


let prtBlockIdent _ (AbsBasilIR.BlockIdent (_,i)) : doc = render i
let rec prtBlockIdentListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtBlockIdent 0 x])
  | (_,x::xs) -> (concatD [prtBlockIdent 0 x ; render "," ; prtBlockIdentListBNFC 0 xs])

let prtProcIdent _ (AbsBasilIR.ProcIdent (_,i)) : doc = render i


let prtBeginList _ (AbsBasilIR.BeginList (_,i)) : doc = render i


let prtEndList _ (AbsBasilIR.EndList (_,i)) : doc = render i


let prtBeginRec _ (AbsBasilIR.BeginRec (_,i)) : doc = render i


let prtEndRec _ (AbsBasilIR.EndRec (_,i)) : doc = render i


let prtLambdaSep _ (AbsBasilIR.LambdaSep i) : doc = render i


let prtStr _ (AbsBasilIR.Str i) : doc = render i


let prtIntegerHex _ (AbsBasilIR.IntegerHex (_,i)) : doc = render i


let prtIntegerDec _ (AbsBasilIR.IntegerDec (_,i)) : doc = render i



let rec prtModuleT (i:int) (e : AbsBasilIR.moduleT) : doc = match e with
       AbsBasilIR.Module1 declarations -> prPrec i 0 (concatD [prtDeclarationListBNFC 0 declarations])


and prtGobbleScolon (i:int) (e : AbsBasilIR.gobbleScolon) : doc = match e with
       AbsBasilIR.EmptyScolon  -> prPrec i 0 (concatD [])
  |    AbsBasilIR.SomeScolon gobblescolon -> prPrec i 0 (concatD [prtGobbleScolon 0 gobblescolon ; render ";"])


and prtDeclaration (i:int) (e : AbsBasilIR.declaration) : doc = match e with
       AbsBasilIR.AxiomDecl (attrdeflist, expr) -> prPrec i 0 (concatD [render "axiom" ; prtAttrDefList 0 attrdeflist ; prtExpr 0 expr])
  |    AbsBasilIR.SharedMemDecl (globalident, type_) -> prPrec i 0 (concatD [render "memory" ; render "shared" ; prtGlobalIdent 0 globalident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.UnsharedMemDecl (globalident, type_) -> prPrec i 0 (concatD [render "memory" ; prtGlobalIdent 0 globalident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.VarDecl (globalident, type_) -> prPrec i 0 (concatD [render "var" ; prtGlobalIdent 0 globalident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.UninterpFunDecl (attrdeflist, globalident, types, type_) -> prPrec i 0 (concatD [render "declare-fun" ; prtAttrDefList 0 attrdeflist ; prtGlobalIdent 0 globalident ; render ":" ; render "(" ; prtTypeTListBNFC 0 types ; render ")" ; render "->" ; prtTypeT 0 type_])
  |    AbsBasilIR.FunDef (attrdeflist, globalident, paramss, type_, expr) -> prPrec i 0 (concatD [render "define-fun" ; prtAttrDefList 0 attrdeflist ; prtGlobalIdent 0 globalident ; render "(" ; prtParamsListBNFC 0 paramss ; render ")" ; render "->" ; prtTypeT 0 type_ ; render "=" ; prtExpr 0 expr])
  |    AbsBasilIR.ProgDeclWithSpec (procident, attrdeflist, beginlist, progspecs, endlist) -> prPrec i 0 (concatD [render "prog" ; render "entry" ; prtProcIdent 0 procident ; prtAttrDefList 0 attrdeflist ; prtBeginList 0 beginlist ; prtProgSpecListBNFC 0 progspecs ; prtEndList 0 endlist])
  |    AbsBasilIR.ProgDecl (procident, attrdeflist) -> prPrec i 0 (concatD [render "prog" ; render "entry" ; prtProcIdent 0 procident ; prtAttrDefList 0 attrdeflist])
  |    AbsBasilIR.Procedure (procsig, attrdeflist, procdef) -> prPrec i 0 (concatD [prtProcSig 0 procsig ; prtAttrDefList 0 attrdeflist ; prtProcDef 0 procdef])

and prtDeclarationListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtDeclaration 0 x ; render ";" ; prtDeclarationListBNFC 0 xs])
and prtProcDef (i:int) (e : AbsBasilIR.procDef) : doc = match e with
       AbsBasilIR.ProcedureDecl funspecdecls -> prPrec i 0 (concatD [prtFunSpecDeclListBNFC 0 funspecdecls])
  |    AbsBasilIR.ProcedureDef (funspecdecls, beginlist, blocks, endlist) -> prPrec i 0 (concatD [prtFunSpecDeclListBNFC 0 funspecdecls ; prtBeginList 0 beginlist ; prtBlockListBNFC 0 blocks ; prtEndList 0 endlist])


and prtIntType (i:int) (e : AbsBasilIR.intType) : doc = match e with
       AbsBasilIR.IntT inttype -> prPrec i 0 (concatD [prtINTTYPE 0 inttype])


and prtBoolType (i:int) (e : AbsBasilIR.boolType) : doc = match e with
       AbsBasilIR.BoolT booltype -> prPrec i 0 (concatD [prtBOOLTYPE 0 booltype])


and prtMapType (i:int) (e : AbsBasilIR.mapType) : doc = match e with
       AbsBasilIR.MapT (type_1, type_2) -> prPrec i 0 (concatD [render "(" ; prtTypeT 0 type_1 ; render "->" ; prtTypeT 0 type_2 ; render ")"])


and prtBVType (i:int) (e : AbsBasilIR.bVType) : doc = match e with
       AbsBasilIR.BVT bvtype -> prPrec i 0 (concatD [prtBVTYPE 0 bvtype])


and prtTypeT (i:int) (e : AbsBasilIR.typeT) : doc = match e with
       AbsBasilIR.TypeIntType inttype -> prPrec i 0 (concatD [prtIntType 0 inttype])
  |    AbsBasilIR.TypeBoolType booltype -> prPrec i 0 (concatD [prtBoolType 0 booltype])
  |    AbsBasilIR.TypeMapType maptype -> prPrec i 0 (concatD [prtMapType 0 maptype])
  |    AbsBasilIR.TypeBVType bvtype -> prPrec i 0 (concatD [prtBVType 0 bvtype])

and prtTypeTListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtTypeT 0 x])
  | (_,x::xs) -> (concatD [prtTypeT 0 x ; render "," ; prtTypeTListBNFC 0 xs])
and prtIntVal (i:int) (e : AbsBasilIR.intVal) : doc = match e with
       AbsBasilIR.HexInt integerhex -> prPrec i 0 (concatD [prtIntegerHex 0 integerhex])
  |    AbsBasilIR.DecInt integerdec -> prPrec i 0 (concatD [prtIntegerDec 0 integerdec])


and prtBVVal (i:int) (e : AbsBasilIR.bVVal) : doc = match e with
       AbsBasilIR.BV (intval, bvtype) -> prPrec i 0 (concatD [prtIntVal 0 intval ; render ":" ; prtBVType 0 bvtype])


and prtEndian (i:int) (e : AbsBasilIR.endian) : doc = match e with
       AbsBasilIR.LittleEndian  -> prPrec i 0 (concatD [render "le"])
  |    AbsBasilIR.BigEndian  -> prPrec i 0 (concatD [render "be"])


and prtAssignment (i:int) (e : AbsBasilIR.assignment) : doc = match e with
       AbsBasilIR.Assignment1 (lvar, expr) -> prPrec i 0 (concatD [prtLVar 0 lvar ; render ":=" ; prtExpr 0 expr])

and prtAssignmentListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtAssignment 0 x])
  | (_,x::xs) -> (concatD [prtAssignment 0 x ; render "," ; prtAssignmentListBNFC 0 xs])
and prtStatement (i:int) (e : AbsBasilIR.statement) : doc = match e with
       AbsBasilIR.Assign assignment -> prPrec i 0 (concatD [prtAssignment 0 assignment])
  |    AbsBasilIR.SimulAssign assignments -> prPrec i 0 (concatD [render "(" ; prtAssignmentListBNFC 0 assignments ; render ")"])
  |    AbsBasilIR.SLoad (lvar, endian, globalident, expr, intval) -> prPrec i 0 (concatD [prtLVar 0 lvar ; render ":=" ; render "load" ; prtEndian 0 endian ; prtGlobalIdent 0 globalident ; prtExpr 0 expr ; prtIntVal 0 intval])
  |    AbsBasilIR.SStore (endian, globalident, expr1, expr2, intval) -> prPrec i 0 (concatD [render "store" ; prtEndian 0 endian ; prtGlobalIdent 0 globalident ; prtExpr 0 expr1 ; prtExpr 0 expr2 ; prtIntVal 0 intval])
  |    AbsBasilIR.DirectCall (calllvars, procident, exprs) -> prPrec i 0 (concatD [prtCallLVars 0 calllvars ; render "call" ; prtProcIdent 0 procident ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])
  |    AbsBasilIR.IndirectCall expr -> prPrec i 0 (concatD [render "indirect" ; render "call" ; prtExpr 0 expr])
  |    AbsBasilIR.Assume (expr, attrdeflist) -> prPrec i 0 (concatD [render "assume" ; prtExpr 0 expr ; prtAttrDefList 0 attrdeflist])
  |    AbsBasilIR.Guard (expr, attrdeflist) -> prPrec i 0 (concatD [render "guard" ; prtExpr 0 expr ; prtAttrDefList 0 attrdeflist])
  |    AbsBasilIR.Assert (expr, attrdeflist) -> prPrec i 0 (concatD [render "assert" ; prtExpr 0 expr ; prtAttrDefList 0 attrdeflist])

and prtStatementListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtStatement 0 x ; render ";" ; prtStatementListBNFC 0 xs])
and prtLocalVar (i:int) (e : AbsBasilIR.localVar) : doc = match e with
       AbsBasilIR.LocalVar1 (localident, type_) -> prPrec i 0 (concatD [prtLocalIdent 0 localident ; render ":" ; prtTypeT 0 type_])

and prtLocalVarListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtLocalVar 0 x])
  | (_,x::xs) -> (concatD [prtLocalVar 0 x ; render "," ; prtLocalVarListBNFC 0 xs])
and prtGlobalVar (i:int) (e : AbsBasilIR.globalVar) : doc = match e with
       AbsBasilIR.GlobalVar1 (globalident, type_) -> prPrec i 0 (concatD [prtGlobalIdent 0 globalident ; render ":" ; prtTypeT 0 type_])


and prtCallLVars (i:int) (e : AbsBasilIR.callLVars) : doc = match e with
       AbsBasilIR.NoOutParams  -> prPrec i 0 (concatD [])
  |    AbsBasilIR.LocalVars localvars -> prPrec i 0 (concatD [render "var" ; render "(" ; prtLocalVarListBNFC 0 localvars ; render ")" ; render ":="])
  |    AbsBasilIR.ListOutParams lvars -> prPrec i 0 (concatD [render "(" ; prtLVarListBNFC 0 lvars ; render ")" ; render ":="])


and prtJump (i:int) (e : AbsBasilIR.jump) : doc = match e with
       AbsBasilIR.GoTo blockidents -> prPrec i 0 (concatD [render "goto" ; render "(" ; prtBlockIdentListBNFC 0 blockidents ; render ")"])
  |    AbsBasilIR.Unreachable  -> prPrec i 0 (concatD [render "unreachable"])
  |    AbsBasilIR.Return exprs -> prPrec i 0 (concatD [render "return" ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])


and prtLVar (i:int) (e : AbsBasilIR.lVar) : doc = match e with
       AbsBasilIR.LVarDef localvar -> prPrec i 0 (concatD [render "var" ; prtLocalVar 0 localvar])
  |    AbsBasilIR.GlobalLVar globalvar -> prPrec i 0 (concatD [prtGlobalVar 0 globalvar])

and prtLVarListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtLVar 0 x])
  | (_,x::xs) -> (concatD [prtLVar 0 x ; render "," ; prtLVarListBNFC 0 xs])
and prtBlock (i:int) (e : AbsBasilIR.block) : doc = match e with
       AbsBasilIR.Block1 (blockident, attrdeflist, beginlist, statements, jump, endlist) -> prPrec i 0 (concatD [render "block" ; prtBlockIdent 0 blockident ; prtAttrDefList 0 attrdeflist ; prtBeginList 0 beginlist ; prtStatementListBNFC 0 statements ; prtJump 0 jump ; render ";" ; prtEndList 0 endlist])

and prtBlockListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtBlock 0 x])
  | (_,x::xs) -> (concatD [prtBlock 0 x ; render ";" ; prtBlockListBNFC 0 xs])
and prtAttrKeyValue (i:int) (e : AbsBasilIR.attrKeyValue) : doc = match e with
       AbsBasilIR.AttrKeyValue1 (bident, attrvalue) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render "=" ; prtAttrValue 0 attrvalue])

and prtAttrKeyValueListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtAttrKeyValue 0 x])
  | (_,x::xs) -> (concatD [prtAttrKeyValue 0 x ; render ";" ; prtAttrKeyValueListBNFC 0 xs])
and prtAttrDefList (i:int) (e : AbsBasilIR.attrDefList) : doc = match e with
       AbsBasilIR.AttrDefListSome (beginrec, attrkeyvalues, gobblescolon, endrec) -> prPrec i 0 (concatD [prtBeginRec 0 beginrec ; prtAttrKeyValueListBNFC 0 attrkeyvalues ; prtGobbleScolon 0 gobblescolon ; prtEndRec 0 endrec])
  |    AbsBasilIR.AttrDefListEmpty  -> prPrec i 0 (concatD [])


and prtAttrValue (i:int) (e : AbsBasilIR.attrValue) : doc = match e with
       AbsBasilIR.MapAttr (beginrec, attrkeyvalues, endrec) -> prPrec i 0 (concatD [prtBeginRec 0 beginrec ; prtAttrKeyValueListBNFC 0 attrkeyvalues ; prtEndRec 0 endrec])
  |    AbsBasilIR.ListAttr (beginlist, attrvalues, endlist) -> prPrec i 0 (concatD [prtBeginList 0 beginlist ; prtAttrValueListBNFC 0 attrvalues ; prtEndList 0 endlist])
  |    AbsBasilIR.LiteralAttr value -> prPrec i 0 (concatD [prtValue 0 value])
  |    AbsBasilIR.StringAttr str -> prPrec i 0 (concatD [prtStr 0 str])

and prtAttrValueListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtAttrValue 0 x])
  | (_,x::xs) -> (concatD [prtAttrValue 0 x ; render ";" ; prtAttrValueListBNFC 0 xs])
and prtParams (i:int) (e : AbsBasilIR.params) : doc = match e with
       AbsBasilIR.Param (localident, type_) -> prPrec i 0 (concatD [prtLocalIdent 0 localident ; render ":" ; prtTypeT 0 type_])

and prtParamsListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtParams 0 x])
  | (_,x::xs) -> (concatD [prtParams 0 x ; render "," ; prtParamsListBNFC 0 xs])
and prtProcSig (i:int) (e : AbsBasilIR.procSig) : doc = match e with
       AbsBasilIR.ProcedureSig (procident, paramss1, paramss2) -> prPrec i 0 (concatD [render "proc" ; prtProcIdent 0 procident ; render "(" ; prtParamsListBNFC 0 paramss1 ; render ")" ; render "->" ; render "(" ; prtParamsListBNFC 0 paramss2 ; render ")"])


and prtValue (i:int) (e : AbsBasilIR.value) : doc = match e with
       AbsBasilIR.BVLiteral bvval -> prPrec i 0 (concatD [prtBVVal 0 bvval])
  |    AbsBasilIR.IntLiteral intval -> prPrec i 0 (concatD [prtIntVal 0 intval])
  |    AbsBasilIR.TrueLiteral  -> prPrec i 0 (concatD [render "true"])
  |    AbsBasilIR.FalseLiteral  -> prPrec i 0 (concatD [render "false"])


and prtExpr (i:int) (e : AbsBasilIR.expr) : doc = match e with
       AbsBasilIR.Literal value -> prPrec i 0 (concatD [prtValue 0 value])
  |    AbsBasilIR.LRVar localvar -> prPrec i 0 (concatD [prtLocalVar 0 localvar])
  |    AbsBasilIR.GRVar globalvar -> prPrec i 0 (concatD [prtGlobalVar 0 globalvar])
  |    AbsBasilIR.Forall lambdadef -> prPrec i 0 (concatD [render "forall" ; prtLambdaDef 0 lambdadef])
  |    AbsBasilIR.Exists lambdadef -> prPrec i 0 (concatD [render "exists" ; prtLambdaDef 0 lambdadef])
  |    AbsBasilIR.OldExpr expr -> prPrec i 0 (concatD [render "old" ; render "(" ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.FunctionOp (globalident, exprs) -> prPrec i 0 (concatD [prtGlobalIdent 0 globalident ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])
  |    AbsBasilIR.BinaryExpr (binop, expr1, expr2) -> prPrec i 0 (concatD [prtBinOp 0 binop ; render "(" ; prtExpr 0 expr1 ; render "," ; prtExpr 0 expr2 ; render ")"])
  |    AbsBasilIR.UnaryExpr (unop, expr) -> prPrec i 0 (concatD [prtUnOp 0 unop ; render "(" ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.ZeroExtend (intval, expr) -> prPrec i 0 (concatD [render "zero_extend" ; render "(" ; prtIntVal 0 intval ; render "," ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.SignExtend (intval, expr) -> prPrec i 0 (concatD [render "sign_extend" ; render "(" ; prtIntVal 0 intval ; render "," ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.Extract (intval1, intval2, expr) -> prPrec i 0 (concatD [render "extract" ; render "(" ; prtIntVal 0 intval1 ; render "," ; prtIntVal 0 intval2 ; render "," ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.Concat (expr1, expr2) -> prPrec i 0 (concatD [render "bvconcat" ; render "(" ; prtExpr 0 expr1 ; render "," ; prtExpr 0 expr2 ; render ")"])

and prtExprListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtExpr 0 x])
  | (_,x::xs) -> (concatD [prtExpr 0 x ; render "," ; prtExprListBNFC 0 xs])
and prtLambdaDef (i:int) (e : AbsBasilIR.lambdaDef) : doc = match e with
       AbsBasilIR.LambdaDef1 (localvars, lambdasep, expr) -> prPrec i 0 (concatD [render "(" ; prtLocalVarListBNFC 0 localvars ; render ")" ; prtLambdaSep 0 lambdasep ; prtExpr 0 expr])


and prtBinOp (i:int) (e : AbsBasilIR.binOp) : doc = match e with
       AbsBasilIR.BinOpBVBinOp bvbinop -> prPrec i 0 (concatD [prtBVBinOp 0 bvbinop])
  |    AbsBasilIR.BinOpBVLogicalBinOp bvlogicalbinop -> prPrec i 0 (concatD [prtBVLogicalBinOp 0 bvlogicalbinop])
  |    AbsBasilIR.BinOpBoolBinOp boolbinop -> prPrec i 0 (concatD [prtBoolBinOp 0 boolbinop])
  |    AbsBasilIR.BinOpIntLogicalBinOp intlogicalbinop -> prPrec i 0 (concatD [prtIntLogicalBinOp 0 intlogicalbinop])
  |    AbsBasilIR.BinOpIntBinOp intbinop -> prPrec i 0 (concatD [prtIntBinOp 0 intbinop])
  |    AbsBasilIR.BinOpEqOp eqop -> prPrec i 0 (concatD [prtEqOp 0 eqop])


and prtUnOp (i:int) (e : AbsBasilIR.unOp) : doc = match e with
       AbsBasilIR.UnOpBVUnOp bvunop -> prPrec i 0 (concatD [prtBVUnOp 0 bvunop])
  |    AbsBasilIR.UnOp_boolnot  -> prPrec i 0 (concatD [render "boolnot"])
  |    AbsBasilIR.UnOp_intneg  -> prPrec i 0 (concatD [render "intneg"])
  |    AbsBasilIR.UnOp_booltobv1  -> prPrec i 0 (concatD [render "booltobv1"])


and prtEqOp (i:int) (e : AbsBasilIR.eqOp) : doc = match e with
       AbsBasilIR.EqOp_eq  -> prPrec i 0 (concatD [render "eq"])
  |    AbsBasilIR.EqOp_neq  -> prPrec i 0 (concatD [render "neq"])


and prtBVUnOp (i:int) (e : AbsBasilIR.bVUnOp) : doc = match e with
       AbsBasilIR.BVUnOp_bvnot  -> prPrec i 0 (concatD [render "bvnot"])
  |    AbsBasilIR.BVUnOp_bvneg  -> prPrec i 0 (concatD [render "bvneg"])


and prtBVBinOp (i:int) (e : AbsBasilIR.bVBinOp) : doc = match e with
       AbsBasilIR.BVBinOp_bvand  -> prPrec i 0 (concatD [render "bvand"])
  |    AbsBasilIR.BVBinOp_bvor  -> prPrec i 0 (concatD [render "bvor"])
  |    AbsBasilIR.BVBinOp_bvadd  -> prPrec i 0 (concatD [render "bvadd"])
  |    AbsBasilIR.BVBinOp_bvmul  -> prPrec i 0 (concatD [render "bvmul"])
  |    AbsBasilIR.BVBinOp_bvudiv  -> prPrec i 0 (concatD [render "bvudiv"])
  |    AbsBasilIR.BVBinOp_bvurem  -> prPrec i 0 (concatD [render "bvurem"])
  |    AbsBasilIR.BVBinOp_bvshl  -> prPrec i 0 (concatD [render "bvshl"])
  |    AbsBasilIR.BVBinOp_bvlshr  -> prPrec i 0 (concatD [render "bvlshr"])
  |    AbsBasilIR.BVBinOp_bvnand  -> prPrec i 0 (concatD [render "bvnand"])
  |    AbsBasilIR.BVBinOp_bvnor  -> prPrec i 0 (concatD [render "bvnor"])
  |    AbsBasilIR.BVBinOp_bvxor  -> prPrec i 0 (concatD [render "bvxor"])
  |    AbsBasilIR.BVBinOp_bvxnor  -> prPrec i 0 (concatD [render "bvxnor"])
  |    AbsBasilIR.BVBinOp_bvcomp  -> prPrec i 0 (concatD [render "bvcomp"])
  |    AbsBasilIR.BVBinOp_bvsub  -> prPrec i 0 (concatD [render "bvsub"])
  |    AbsBasilIR.BVBinOp_bvsdiv  -> prPrec i 0 (concatD [render "bvsdiv"])
  |    AbsBasilIR.BVBinOp_bvsrem  -> prPrec i 0 (concatD [render "bvsrem"])
  |    AbsBasilIR.BVBinOp_bvsmod  -> prPrec i 0 (concatD [render "bvsmod"])
  |    AbsBasilIR.BVBinOp_bvashr  -> prPrec i 0 (concatD [render "bvashr"])


and prtBVLogicalBinOp (i:int) (e : AbsBasilIR.bVLogicalBinOp) : doc = match e with
       AbsBasilIR.BVLogicalBinOp_bvule  -> prPrec i 0 (concatD [render "bvule"])
  |    AbsBasilIR.BVLogicalBinOp_bvugt  -> prPrec i 0 (concatD [render "bvugt"])
  |    AbsBasilIR.BVLogicalBinOp_bvuge  -> prPrec i 0 (concatD [render "bvuge"])
  |    AbsBasilIR.BVLogicalBinOp_bvult  -> prPrec i 0 (concatD [render "bvult"])
  |    AbsBasilIR.BVLogicalBinOp_bvslt  -> prPrec i 0 (concatD [render "bvslt"])
  |    AbsBasilIR.BVLogicalBinOp_bvsle  -> prPrec i 0 (concatD [render "bvsle"])
  |    AbsBasilIR.BVLogicalBinOp_bvsgt  -> prPrec i 0 (concatD [render "bvsgt"])
  |    AbsBasilIR.BVLogicalBinOp_bvsge  -> prPrec i 0 (concatD [render "bvsge"])


and prtIntBinOp (i:int) (e : AbsBasilIR.intBinOp) : doc = match e with
       AbsBasilIR.IntBinOp_intadd  -> prPrec i 0 (concatD [render "intadd"])
  |    AbsBasilIR.IntBinOp_intmul  -> prPrec i 0 (concatD [render "intmul"])
  |    AbsBasilIR.IntBinOp_intsub  -> prPrec i 0 (concatD [render "intsub"])
  |    AbsBasilIR.IntBinOp_intdiv  -> prPrec i 0 (concatD [render "intdiv"])
  |    AbsBasilIR.IntBinOp_intmod  -> prPrec i 0 (concatD [render "intmod"])


and prtIntLogicalBinOp (i:int) (e : AbsBasilIR.intLogicalBinOp) : doc = match e with
       AbsBasilIR.IntLogicalBinOp_intlt  -> prPrec i 0 (concatD [render "intlt"])
  |    AbsBasilIR.IntLogicalBinOp_intle  -> prPrec i 0 (concatD [render "intle"])
  |    AbsBasilIR.IntLogicalBinOp_intgt  -> prPrec i 0 (concatD [render "intgt"])
  |    AbsBasilIR.IntLogicalBinOp_intge  -> prPrec i 0 (concatD [render "intge"])


and prtBoolBinOp (i:int) (e : AbsBasilIR.boolBinOp) : doc = match e with
       AbsBasilIR.BoolBinOp_booland  -> prPrec i 0 (concatD [render "booland"])
  |    AbsBasilIR.BoolBinOp_boolor  -> prPrec i 0 (concatD [render "boolor"])
  |    AbsBasilIR.BoolBinOp_boolimplies  -> prPrec i 0 (concatD [render "boolimplies"])


and prtRequireTok (i:int) (e : AbsBasilIR.requireTok) : doc = match e with
       AbsBasilIR.RequireTok_require  -> prPrec i 0 (concatD [render "require"])
  |    AbsBasilIR.RequireTok_requires  -> prPrec i 0 (concatD [render "requires"])


and prtEnsureTok (i:int) (e : AbsBasilIR.ensureTok) : doc = match e with
       AbsBasilIR.EnsureTok_ensure  -> prPrec i 0 (concatD [render "ensure"])
  |    AbsBasilIR.EnsureTok_ensures  -> prPrec i 0 (concatD [render "ensures"])


and prtFunSpecDecl (i:int) (e : AbsBasilIR.funSpecDecl) : doc = match e with
       AbsBasilIR.Require (requiretok, expr) -> prPrec i 0 (concatD [prtRequireTok 0 requiretok ; prtExpr 0 expr])
  |    AbsBasilIR.Ensure (ensuretok, expr) -> prPrec i 0 (concatD [prtEnsureTok 0 ensuretok ; prtExpr 0 expr])
  |    AbsBasilIR.LoopInvariant (blockident, expr) -> prPrec i 0 (concatD [render "invariant" ; prtBlockIdent 0 blockident ; prtExpr 0 expr])

and prtFunSpecDeclListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtFunSpecDecl 0 x ; render ";" ; prtFunSpecDeclListBNFC 0 xs])
and prtProgSpec (i:int) (e : AbsBasilIR.progSpec) : doc = match e with
       AbsBasilIR.Rely expr -> prPrec i 0 (concatD [render "rely" ; prtExpr 0 expr])
  |    AbsBasilIR.Guarantee expr -> prPrec i 0 (concatD [render "guarantee" ; prtExpr 0 expr])

and prtProgSpecListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtProgSpec 0 x ; render ";" ; prtProgSpecListBNFC 0 xs])


(* File generated by the BNF Converter (bnfc 2.9.5). *)

(* pretty-printer *)

open Printf

(* We use string buffers for efficient string concatenation.
   A document takes a buffer and an indentation, has side effects on the buffer
   and returns a new indentation. The indentation argument indicates the level
   of indentation to be used if a new line has to be started (because of what is
   already in the buffer) *)
type doc = Buffer.t -> int -> int

let rec printTree (printer : int -> 'a -> doc) (tree : 'a) : string =
    let buffer_init_size = 64 (* you may want to change this *)
    in let buffer = Buffer.create buffer_init_size
    in
        let _ = printer 0 tree buffer 0 in (* discard return value *)
        Buffer.contents buffer

let indent_width = 2

let spaces (i: int) : string = if i > 0 then String.make i ' ' else ""
let indent (i: int) : string = "\n" ^ spaces i

(* To avoid dependency on package extlib, which has
   Extlib.ExtChar.Char.is_whitespace, we employ the following awkward
   way to check a character for whitespace.
   Note: String.trim exists in the core libraries since Ocaml 4.00. *)
let isWhiteSpace (c: char) : bool = String.trim (String.make 1 c) = ""

(* this render function is written for C-style languages, you may want to change it *)
let render (s : string) : doc = fun buf i ->
    (* invariant: last char of the buffer is never whitespace *)
    let n = Buffer.length buf in
    let last = if n = 0 then None else Some (Buffer.nth buf (n-1)) in
    let newindent = match s with
        "{" -> i + indent_width
      | "}" -> i - indent_width
      | _ -> i in
    let whitespace = match last with
        None -> ""
      | Some '}' -> (match s with
            ";" -> ""
          | _ -> indent newindent)
      | (Some '{') | (Some ';') -> if s = "}" then indent newindent else indent i
      | (Some '[') | (Some '(') -> ""
      | Some c -> if isWhiteSpace c then "" else (match s with
             ";" | "," | ")" | "]" -> ""
           | "{" -> indent i
           | "}" -> indent newindent
           | _ -> if String.trim s = "" then "" else " ") in
    Buffer.add_string buf whitespace;
    Buffer.add_string buf s;
    newindent

let emptyDoc : doc = fun buf i -> i

let concatD (ds : doc list) : doc = fun buf i ->
    List.fold_left (fun accIndent elemDoc -> elemDoc buf accIndent) (emptyDoc buf i) ds

let parenth (d:doc) : doc = concatD [render "("; d; render ")"]

let prPrec (i:int) (j:int) (d:doc) : doc = if j<i then parenth d else d


let prtChar (_:int) (c:char) : doc = render ("'" ^ Char.escaped c ^ "'")



let prtInt (_:int) (i:int) : doc = render (string_of_int i)



let prtFloat (_:int) (f:float) : doc = render (sprintf "%.15g" f)



let prtString (_:int) (s:string) : doc = render ("\"" ^ String.escaped s ^ "\"")




let prtBVTYPE _ (AbsBasilIR.BVTYPE i) : doc = render i


let prtUserIdent _ (AbsBasilIR.UserIdent (_,i)) : doc = render i


let prtBIdent _ (AbsBasilIR.BIdent (_,i)) : doc = render i


let prtLocalIdent _ (AbsBasilIR.LocalIdent (_,i)) : doc = render i


let prtGlobalIdent _ (AbsBasilIR.GlobalIdent (_,i)) : doc = render i


let prtBlockIdent _ (AbsBasilIR.BlockIdent (_,i)) : doc = render i
let rec prtBlockIdentListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtBlockIdent 0 x])
  | (_,x::xs) -> (concatD [prtBlockIdent 0 x ; render "," ; prtBlockIdentListBNFC 0 xs])

let prtProcIdent _ (AbsBasilIR.ProcIdent (_,i)) : doc = render i


let prtBeginList _ (AbsBasilIR.BeginList (_,i)) : doc = render i


let prtEndList _ (AbsBasilIR.EndList (_,i)) : doc = render i


let prtBeginRec _ (AbsBasilIR.BeginRec (_,i)) : doc = render i


let prtEndRec _ (AbsBasilIR.EndRec (_,i)) : doc = render i


let prtStr _ (AbsBasilIR.Str i) : doc = render i


let prtIntegerHex _ (AbsBasilIR.IntegerHex i) : doc = render i


let prtBitvectorHex _ (AbsBasilIR.BitvectorHex i) : doc = render i



let rec prtProgram (i:int) (e : AbsBasilIR.program) : doc = match e with
       AbsBasilIR.Prog declarations -> prPrec i 0 (concatD [prtDeclarationListBNFC 0 declarations])


and prtDeclaration (i:int) (e : AbsBasilIR.declaration) : doc = match e with
       AbsBasilIR.AxiomDecl (attrdeflist, expr) -> prPrec i 0 (concatD [render "axiom" ; prtAttrDefList 0 attrdeflist ; prtExpr 0 expr])
  |    AbsBasilIR.MemDecl (globalident, type_) -> prPrec i 0 (concatD [render "memory" ; prtGlobalIdent 0 globalident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.VarDecl (globalident, type_) -> prPrec i 0 (concatD [render "var" ; prtGlobalIdent 0 globalident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.ProgDecl (attrdeflist, thrspecdecls) -> prPrec i 0 (concatD [render "prog" ; prtAttrDefList 0 attrdeflist ; prtThrSpecDeclListBNFC 0 thrspecdecls])
  |    AbsBasilIR.Procedure procdef -> prPrec i 0 (concatD [prtProcDef 0 procdef])

and prtDeclarationListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtDeclaration 0 x ; render ";" ; prtDeclarationListBNFC 0 xs])
and prtIntType (i:int) (e : AbsBasilIR.intType) : doc = match e with
       AbsBasilIR.IntT  -> prPrec i 0 (concatD [render "int"])


and prtBoolType (i:int) (e : AbsBasilIR.boolType) : doc = match e with
       AbsBasilIR.BoolT  -> prPrec i 0 (concatD [render "bool"])


and prtMapType (i:int) (e : AbsBasilIR.mapType) : doc = match e with
       AbsBasilIR.MapT (type_1, beginlist, type_2, endlist) -> prPrec i 0 (concatD [render "map" ; prtTypeT 0 type_1 ; prtBeginList 0 beginlist ; prtTypeT 0 type_2 ; prtEndList 0 endlist])


and prtBVType (i:int) (e : AbsBasilIR.bVType) : doc = match e with
       AbsBasilIR.BVT bvtype -> prPrec i 0 (concatD [prtBVTYPE 0 bvtype])


and prtTypeT (i:int) (e : AbsBasilIR.typeT) : doc = match e with
       AbsBasilIR.TypeIntType inttype -> prPrec i 0 (concatD [prtIntType 0 inttype])
  |    AbsBasilIR.TypeBoolType booltype -> prPrec i 0 (concatD [prtBoolType 0 booltype])
  |    AbsBasilIR.TypeMapType maptype -> prPrec i 0 (concatD [prtMapType 0 maptype])
  |    AbsBasilIR.TypeBVType bvtype -> prPrec i 0 (concatD [prtBVType 0 bvtype])


and prtIntVal (i:int) (e : AbsBasilIR.intVal) : doc = match e with
       AbsBasilIR.HexInt integerhex -> prPrec i 0 (concatD [prtIntegerHex 0 integerhex])
  |    AbsBasilIR.DecInt integer -> prPrec i 0 (concatD [prtInt 0 integer])


and prtBVVal (i:int) (e : AbsBasilIR.bVVal) : doc = match e with
       AbsBasilIR.BV (intval, bvtype) -> prPrec i 0 (concatD [prtIntVal 0 intval ; render ":" ; prtBVType 0 bvtype])


and prtEndian (i:int) (e : AbsBasilIR.endian) : doc = match e with
       AbsBasilIR.LittleEndian  -> prPrec i 0 (concatD [render "le"])
  |    AbsBasilIR.BigEndian  -> prPrec i 0 (concatD [render "be"])


and prtAssignment (i:int) (e : AbsBasilIR.assignment) : doc = match e with
       AbsBasilIR.Assignment1 (lvar, expr) -> prPrec i 0 (concatD [prtLVar 0 lvar ; render ":=" ; prtExpr 0 expr])

and prtAssignmentListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtAssignment 0 x])
  | (_,x::xs) -> (concatD [prtAssignment 0 x ; render "," ; prtAssignmentListBNFC 0 xs])
and prtStatement (i:int) (e : AbsBasilIR.statement) : doc = match e with
       AbsBasilIR.Assign assignment -> prPrec i 0 (concatD [prtAssignment 0 assignment])
  |    AbsBasilIR.SimulAssign assignments -> prPrec i 0 (concatD [render "(" ; prtAssignmentListBNFC 0 assignments ; render ")"])
  |    AbsBasilIR.SLoad (lvar, endian, globalident, expr, intval) -> prPrec i 0 (concatD [prtLVar 0 lvar ; render ":=" ; render "load" ; prtEndian 0 endian ; prtGlobalIdent 0 globalident ; prtExpr 0 expr ; prtIntVal 0 intval])
  |    AbsBasilIR.SStore (endian, globalident, expr1, expr2, intval) -> prPrec i 0 (concatD [render "store" ; prtEndian 0 endian ; prtGlobalIdent 0 globalident ; prtExpr 0 expr1 ; prtExpr 0 expr2 ; prtIntVal 0 intval])
  |    AbsBasilIR.DirectCall (calllvars, procident, exprs) -> prPrec i 0 (concatD [prtCallLVars 0 calllvars ; render "call" ; prtProcIdent 0 procident ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])
  |    AbsBasilIR.IndirectCall expr -> prPrec i 0 (concatD [render "indirect" ; render "call" ; prtExpr 0 expr])
  |    AbsBasilIR.Assume expr -> prPrec i 0 (concatD [render "assume" ; prtExpr 0 expr])
  |    AbsBasilIR.Assert expr -> prPrec i 0 (concatD [render "assert" ; prtExpr 0 expr])

and prtStatementListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtStatement 0 x ; render ";" ; prtStatementListBNFC 0 xs])
and prtLocalVar (i:int) (e : AbsBasilIR.localVar) : doc = match e with
       AbsBasilIR.LocalVar1 (localident, type_) -> prPrec i 0 (concatD [prtLocalIdent 0 localident ; render ":" ; prtTypeT 0 type_])

and prtLocalVarListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtLocalVar 0 x])
  | (_,x::xs) -> (concatD [prtLocalVar 0 x ; render "," ; prtLocalVarListBNFC 0 xs])
and prtGlobalVar (i:int) (e : AbsBasilIR.globalVar) : doc = match e with
       AbsBasilIR.GlobalVar1 (globalident, type_) -> prPrec i 0 (concatD [prtGlobalIdent 0 globalident ; render ":" ; prtTypeT 0 type_])


and prtCallLVars (i:int) (e : AbsBasilIR.callLVars) : doc = match e with
       AbsBasilIR.NoOutParams  -> prPrec i 0 (concatD [])
  |    AbsBasilIR.LocalVars localvars -> prPrec i 0 (concatD [render "var" ; render "(" ; prtLocalVarListBNFC 0 localvars ; render ")" ; render ":="])
  |    AbsBasilIR.ListOutParams lvars -> prPrec i 0 (concatD [render "(" ; prtLVarListBNFC 0 lvars ; render ")" ; render ":="])


and prtJump (i:int) (e : AbsBasilIR.jump) : doc = match e with
       AbsBasilIR.GoTo blockidents -> prPrec i 0 (concatD [render "goto" ; render "(" ; prtBlockIdentListBNFC 0 blockidents ; render ")"])
  |    AbsBasilIR.Unreachable  -> prPrec i 0 (concatD [render "unreachable"])
  |    AbsBasilIR.Return exprs -> prPrec i 0 (concatD [render "return" ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])


and prtLVar (i:int) (e : AbsBasilIR.lVar) : doc = match e with
       AbsBasilIR.LVarDef localvar -> prPrec i 0 (concatD [render "var" ; prtLocalVar 0 localvar])
  |    AbsBasilIR.GlobalLVar globalvar -> prPrec i 0 (concatD [prtGlobalVar 0 globalvar])

and prtLVarListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtLVar 0 x])
  | (_,x::xs) -> (concatD [prtLVar 0 x ; render "," ; prtLVarListBNFC 0 xs])
and prtBlock (i:int) (e : AbsBasilIR.block) : doc = match e with
       AbsBasilIR.Block1 (blockident, attrdeflist, beginlist, statements, jump, endlist) -> prPrec i 0 (concatD [render "block" ; prtBlockIdent 0 blockident ; prtAttrDefList 0 attrdeflist ; prtBeginList 0 beginlist ; prtStatementListBNFC 0 statements ; prtJump 0 jump ; prtEndList 0 endlist])

and prtBlockListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtBlock 0 x])
  | (_,x::xs) -> (concatD [prtBlock 0 x ; render ";" ; prtBlockListBNFC 0 xs])
and prtAttributeItem (i:int) (e : AbsBasilIR.attributeItem) : doc = match e with
       AbsBasilIR.IntAttr (bident, intval) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render "=" ; prtIntVal 0 intval])
  |    AbsBasilIR.BVAttr (bident, bvval) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render "=" ; prtBVVal 0 bvval])
  |    AbsBasilIR.ExprAttr (bident, expr) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render "=" ; prtExpr 0 expr])
  |    AbsBasilIR.StringAttr (bident, str) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render "=" ; prtStr 0 str])

and prtAttributeItemListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtAttributeItem 0 x])
  | (_,x::xs) -> (concatD [prtAttributeItem 0 x ; render ";" ; prtAttributeItemListBNFC 0 xs])
and prtAttrDefList (i:int) (e : AbsBasilIR.attrDefList) : doc = match e with
       AbsBasilIR.AttrDefListSome (beginrec, attributeitems, endrec) -> prPrec i 0 (concatD [prtBeginRec 0 beginrec ; prtAttributeItemListBNFC 0 attributeitems ; prtEndRec 0 endrec])
  |    AbsBasilIR.AttrDefListEmpty  -> prPrec i 0 (concatD [])


and prtParams (i:int) (e : AbsBasilIR.params) : doc = match e with
       AbsBasilIR.Param (localident, type_) -> prPrec i 0 (concatD [prtLocalIdent 0 localident ; render ":" ; prtTypeT 0 type_])

and prtParamsListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtParams 0 x])
  | (_,x::xs) -> (concatD [prtParams 0 x ; render "," ; prtParamsListBNFC 0 xs])
and prtProcSig (i:int) (e : AbsBasilIR.procSig) : doc = match e with
       AbsBasilIR.ProcedureSig (procident, paramss1, paramss2) -> prPrec i 0 (concatD [render "proc" ; prtProcIdent 0 procident ; render "(" ; prtParamsListBNFC 0 paramss1 ; render ")" ; render "->" ; render "(" ; prtParamsListBNFC 0 paramss2 ; render ")"])


and prtProcDef (i:int) (e : AbsBasilIR.procDef) : doc = match e with
       AbsBasilIR.ProcedureDecl (procsig, attrdeflist) -> prPrec i 0 (concatD [prtProcSig 0 procsig ; prtAttrDefList 0 attrdeflist])
  |    AbsBasilIR.ProcedureDef (procsig, attrdeflist, beginlist, blocks, endlist) -> prPrec i 0 (concatD [prtProcSig 0 procsig ; prtAttrDefList 0 attrdeflist ; prtBeginList 0 beginlist ; prtBlockListBNFC 0 blocks ; prtEndList 0 endlist])


and prtExpr (i:int) (e : AbsBasilIR.expr) : doc = match e with
       AbsBasilIR.BVLiteral bvval -> prPrec i 0 (concatD [prtBVVal 0 bvval])
  |    AbsBasilIR.IntLiteral intval -> prPrec i 0 (concatD [prtIntVal 0 intval])
  |    AbsBasilIR.TrueLiteral  -> prPrec i 0 (concatD [render "true"])
  |    AbsBasilIR.FalseLiteral  -> prPrec i 0 (concatD [render "false"])
  |    AbsBasilIR.LRVar localvar -> prPrec i 0 (concatD [prtLocalVar 0 localvar])
  |    AbsBasilIR.GRVar globalvar -> prPrec i 0 (concatD [prtGlobalVar 0 globalvar])
  |    AbsBasilIR.FunctionOp (globalident, exprs) -> prPrec i 0 (concatD [prtGlobalIdent 0 globalident ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])

and prtExprListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtExpr 0 x])
  | (_,[x]) -> (concatD [prtExpr 0 x])
  | (_,x::xs) -> (concatD [prtExpr 0 x ; render "," ; prtExprListBNFC 0 xs])
  | (_,x::xs) -> (concatD [prtExpr 0 x ; render "," ; prtExprListBNFC 0 xs])
and prtEqOp (i:int) (e : AbsBasilIR.eqOp) : doc = match e with
       AbsBasilIR.EqOp_eq  -> prPrec i 0 (concatD [render "eq"])
  |    AbsBasilIR.EqOp_neq  -> prPrec i 0 (concatD [render "neq"])


and prtBVUnOp (i:int) (e : AbsBasilIR.bVUnOp) : doc = match e with
       AbsBasilIR.BVUnOp_bvnot  -> prPrec i 0 (concatD [render "bvnot"])
  |    AbsBasilIR.BVUnOp_bvneg  -> prPrec i 0 (concatD [render "bvneg"])


and prtBVBinOp (i:int) (e : AbsBasilIR.bVBinOp) : doc = match e with
       AbsBasilIR.BVBinOp_bvand  -> prPrec i 0 (concatD [render "bvand"])
  |    AbsBasilIR.BVBinOp_bvor  -> prPrec i 0 (concatD [render "bvor"])
  |    AbsBasilIR.BVBinOp_bvadd  -> prPrec i 0 (concatD [render "bvadd"])
  |    AbsBasilIR.BVBinOp_bvmul  -> prPrec i 0 (concatD [render "bvmul"])
  |    AbsBasilIR.BVBinOp_bvudiv  -> prPrec i 0 (concatD [render "bvudiv"])
  |    AbsBasilIR.BVBinOp_bvurem  -> prPrec i 0 (concatD [render "bvurem"])
  |    AbsBasilIR.BVBinOp_bvshl  -> prPrec i 0 (concatD [render "bvshl"])
  |    AbsBasilIR.BVBinOp_bvlshr  -> prPrec i 0 (concatD [render "bvlshr"])
  |    AbsBasilIR.BVBinOp_bvnand  -> prPrec i 0 (concatD [render "bvnand"])
  |    AbsBasilIR.BVBinOp_bvnor  -> prPrec i 0 (concatD [render "bvnor"])
  |    AbsBasilIR.BVBinOp_bvxor  -> prPrec i 0 (concatD [render "bvxor"])
  |    AbsBasilIR.BVBinOp_bvxnor  -> prPrec i 0 (concatD [render "bvxnor"])
  |    AbsBasilIR.BVBinOp_bvcomp  -> prPrec i 0 (concatD [render "bvcomp"])
  |    AbsBasilIR.BVBinOp_bvsub  -> prPrec i 0 (concatD [render "bvsub"])
  |    AbsBasilIR.BVBinOp_bvsdiv  -> prPrec i 0 (concatD [render "bvsdiv"])
  |    AbsBasilIR.BVBinOp_bvsrem  -> prPrec i 0 (concatD [render "bvsrem"])
  |    AbsBasilIR.BVBinOp_bvsmod  -> prPrec i 0 (concatD [render "bvsmod"])
  |    AbsBasilIR.BVBinOp_bvashr  -> prPrec i 0 (concatD [render "bvashr"])


and prtBVLogicalBinOp (i:int) (e : AbsBasilIR.bVLogicalBinOp) : doc = match e with
       AbsBasilIR.BVLogicalBinOp_bvule  -> prPrec i 0 (concatD [render "bvule"])
  |    AbsBasilIR.BVLogicalBinOp_bvugt  -> prPrec i 0 (concatD [render "bvugt"])
  |    AbsBasilIR.BVLogicalBinOp_bvuge  -> prPrec i 0 (concatD [render "bvuge"])
  |    AbsBasilIR.BVLogicalBinOp_bvult  -> prPrec i 0 (concatD [render "bvult"])
  |    AbsBasilIR.BVLogicalBinOp_bvslt  -> prPrec i 0 (concatD [render "bvslt"])
  |    AbsBasilIR.BVLogicalBinOp_bvsle  -> prPrec i 0 (concatD [render "bvsle"])
  |    AbsBasilIR.BVLogicalBinOp_bvsgt  -> prPrec i 0 (concatD [render "bvsgt"])
  |    AbsBasilIR.BVLogicalBinOp_bvsge  -> prPrec i 0 (concatD [render "bvsge"])


and prtIntBinOp (i:int) (e : AbsBasilIR.intBinOp) : doc = match e with
       AbsBasilIR.IntBinOp_intadd  -> prPrec i 0 (concatD [render "intadd"])
  |    AbsBasilIR.IntBinOp_intmul  -> prPrec i 0 (concatD [render "intmul"])
  |    AbsBasilIR.IntBinOp_intsub  -> prPrec i 0 (concatD [render "intsub"])
  |    AbsBasilIR.IntBinOp_intdiv  -> prPrec i 0 (concatD [render "intdiv"])
  |    AbsBasilIR.IntBinOp_intmod  -> prPrec i 0 (concatD [render "intmod"])


and prtIntLogicalBinOp (i:int) (e : AbsBasilIR.intLogicalBinOp) : doc = match e with
       AbsBasilIR.IntLogicalBinOp_intlt  -> prPrec i 0 (concatD [render "intlt"])
  |    AbsBasilIR.IntLogicalBinOp_intle  -> prPrec i 0 (concatD [render "intle"])
  |    AbsBasilIR.IntLogicalBinOp_intgt  -> prPrec i 0 (concatD [render "intgt"])
  |    AbsBasilIR.IntLogicalBinOp_intge  -> prPrec i 0 (concatD [render "intge"])


and prtBoolBinOp (i:int) (e : AbsBasilIR.boolBinOp) : doc = match e with
       AbsBasilIR.BoolBinOp_booland  -> prPrec i 0 (concatD [render "booland"])
  |    AbsBasilIR.BoolBinOp_boolor  -> prPrec i 0 (concatD [render "boolor"])
  |    AbsBasilIR.BoolBinOp_boolimplies  -> prPrec i 0 (concatD [render "boolimplies"])


and prtFunSpecDecl (i:int) (e : AbsBasilIR.funSpecDecl) : doc = match e with
       AbsBasilIR.Require expr -> prPrec i 0 (concatD [render "require" ; prtExpr 0 expr])
  |    AbsBasilIR.Ensure expr -> prPrec i 0 (concatD [render "ensure" ; prtExpr 0 expr])
  |    AbsBasilIR.LoopInvariant (blockident, expr) -> prPrec i 0 (concatD [render "invariant" ; prtBlockIdent 0 blockident ; prtExpr 0 expr])

and prtFunSpecDeclListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtFunSpecDecl 0 x ; render ";" ; prtFunSpecDeclListBNFC 0 xs])
and prtThrSpecDecl (i:int) (e : AbsBasilIR.thrSpecDecl) : doc = match e with
       AbsBasilIR.Rely expr -> prPrec i 0 (concatD [render "rely" ; prtExpr 0 expr])
  |    AbsBasilIR.Guarantee expr -> prPrec i 0 (concatD [render "guarantee" ; prtExpr 0 expr])

and prtThrSpecDeclListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtThrSpecDecl 0 x ; render ";" ; prtThrSpecDeclListBNFC 0 xs])


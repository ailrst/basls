(* File generated by the BNF Converter (bnfc 2.9.5). *)

(* pretty-printer *)

open Printf

(* We use string buffers for efficient string concatenation.
   A document takes a buffer and an indentation, has side effects on the buffer
   and returns a new indentation. The indentation argument indicates the level
   of indentation to be used if a new line has to be started (because of what is
   already in the buffer) *)
type doc = Buffer.t -> int -> int

let rec printTree (printer : int -> 'a -> doc) (tree : 'a) : string =
    let buffer_init_size = 64 (* you may want to change this *)
    in let buffer = Buffer.create buffer_init_size
    in
        let _ = printer 0 tree buffer 0 in (* discard return value *)
        Buffer.contents buffer

let indent_width = 2

let spaces (i: int) : string = if i > 0 then String.make i ' ' else ""
let indent (i: int) : string = "\n" ^ spaces i

(* To avoid dependency on package extlib, which has
   Extlib.ExtChar.Char.is_whitespace, we employ the following awkward
   way to check a character for whitespace.
   Note: String.trim exists in the core libraries since Ocaml 4.00. *)
let isWhiteSpace (c: char) : bool = String.trim (String.make 1 c) = ""

(* this render function is written for C-style languages, you may want to change it *)
let render (s : string) : doc = fun buf i ->
    (* invariant: last char of the buffer is never whitespace *)
    let n = Buffer.length buf in
    let last = if n = 0 then None else Some (Buffer.nth buf (n-1)) in
    let newindent = match s with
        "{" -> i + indent_width
      | "}" -> i - indent_width
      | _ -> i in
    let whitespace = match last with
        None -> ""
      | Some '}' -> (match s with
            ";" -> ""
          | _ -> indent newindent)
      | (Some '{') | (Some ';') -> if s = "}" then indent newindent else indent i
      | (Some '[') | (Some '(') -> ""
      | Some c -> if isWhiteSpace c then "" else (match s with
             ";" | "," | ")" | "]" -> ""
           | "{" -> indent i
           | "}" -> indent newindent
           | _ -> if String.trim s = "" then "" else " ") in
    Buffer.add_string buf whitespace;
    Buffer.add_string buf s;
    newindent

let emptyDoc : doc = fun buf i -> i

let concatD (ds : doc list) : doc = fun buf i ->
    List.fold_left (fun accIndent elemDoc -> elemDoc buf accIndent) (emptyDoc buf i) ds

let parenth (d:doc) : doc = concatD [render "("; d; render ")"]

let prPrec (i:int) (j:int) (d:doc) : doc = if j<i then parenth d else d


let prtChar (_:int) (c:char) : doc = render ("'" ^ Char.escaped c ^ "'")



let prtInt (_:int) (i:int) : doc = render (string_of_int i)



let prtFloat (_:int) (f:float) : doc = render (sprintf "%.15g" f)



let prtString (_:int) (s:string) : doc = render ("\"" ^ String.escaped s ^ "\"")




let prtBVTYPE _ (AbsBasilIR.BVTYPE i) : doc = render i


let prtBIdent _ (AbsBasilIR.BIdent (_,i)) : doc = render i
let rec prtBIdentListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtBIdent 0 x])
  | (_,x::xs) -> (concatD [prtBIdent 0 x ; render "," ; prtBIdentListBNFC 0 xs])

let prtBeginList _ (AbsBasilIR.BeginList (_,i)) : doc = render i


let prtEndList _ (AbsBasilIR.EndList (_,i)) : doc = render i


let prtBeginRec _ (AbsBasilIR.BeginRec (_,i)) : doc = render i


let prtEndRec _ (AbsBasilIR.EndRec (_,i)) : doc = render i


let prtStr _ (AbsBasilIR.Str i) : doc = render i


let prtIntegerHex _ (AbsBasilIR.IntegerHex i) : doc = render i


let prtBitvectorHex _ (AbsBasilIR.BitvectorHex i) : doc = render i



let rec prtProgram (i:int) (e : AbsBasilIR.program) : doc = match e with
       AbsBasilIR.Prog declarations -> prPrec i 0 (concatD [prtDeclarationListBNFC 0 declarations])


and prtDeclaration (i:int) (e : AbsBasilIR.declaration) : doc = match e with
       AbsBasilIR.LetDecl (bident, mexpr) -> prPrec i 0 (concatD [render "let" ; prtBIdent 0 bident ; render "=" ; prtMExpr 0 mexpr])
  |    AbsBasilIR.MemDecl (bident, type_) -> prPrec i 0 (concatD [render "memory" ; prtBIdent 0 bident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.VarDecl (bident, type_) -> prPrec i 0 (concatD [render "var" ; prtBIdent 0 bident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.Procedure (bident, paramss1, paramss2, procdef) -> prPrec i 0 (concatD [render "proc" ; prtBIdent 0 bident ; render "(" ; prtParamsListBNFC 0 paramss1 ; render ")" ; render "->" ; render "(" ; prtParamsListBNFC 0 paramss2 ; render ")" ; prtProcDef 0 procdef])

and prtDeclarationListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtDeclaration 0 x])
  | (_,x::xs) -> (concatD [prtDeclaration 0 x ; render ";" ; prtDeclarationListBNFC 0 xs])
and prtMExpr (i:int) (e : AbsBasilIR.mExpr) : doc = match e with
       AbsBasilIR.MSym bident -> prPrec i 0 (concatD [prtBIdent 0 bident])
  |    AbsBasilIR.BlockM block -> prPrec i 0 (concatD [prtBlock 0 block])


and prtIntType (i:int) (e : AbsBasilIR.intType) : doc = match e with
       AbsBasilIR.IntT  -> prPrec i 0 (concatD [render "int"])


and prtBoolType (i:int) (e : AbsBasilIR.boolType) : doc = match e with
       AbsBasilIR.BoolT  -> prPrec i 0 (concatD [render "bool"])


and prtMapType (i:int) (e : AbsBasilIR.mapType) : doc = match e with
       AbsBasilIR.MapT (type_1, beginlist, type_2, endlist) -> prPrec i 0 (concatD [render "map" ; prtTypeT 0 type_1 ; prtBeginList 0 beginlist ; prtTypeT 0 type_2 ; prtEndList 0 endlist])


and prtBVType (i:int) (e : AbsBasilIR.bVType) : doc = match e with
       AbsBasilIR.BVT bvtype -> prPrec i 0 (concatD [prtBVTYPE 0 bvtype])


and prtTypeT (i:int) (e : AbsBasilIR.typeT) : doc = match e with
       AbsBasilIR.TypeIntType inttype -> prPrec i 0 (concatD [prtIntType 0 inttype])
  |    AbsBasilIR.TypeBoolType booltype -> prPrec i 0 (concatD [prtBoolType 0 booltype])
  |    AbsBasilIR.TypeMapType maptype -> prPrec i 0 (concatD [prtMapType 0 maptype])
  |    AbsBasilIR.TypeBVType bvtype -> prPrec i 0 (concatD [prtBVType 0 bvtype])


and prtIntVal (i:int) (e : AbsBasilIR.intVal) : doc = match e with
       AbsBasilIR.HexInt integerhex -> prPrec i 0 (concatD [prtIntegerHex 0 integerhex])
  |    AbsBasilIR.DecInt integer -> prPrec i 0 (concatD [prtInt 0 integer])


and prtAddrAttr (i:int) (e : AbsBasilIR.addrAttr) : doc = match e with
       AbsBasilIR.AddrAttrSome (beginrec, intval, endrec) -> prPrec i 0 (concatD [prtBeginRec 0 beginrec ; render "address" ; render "=" ; prtIntVal 0 intval ; prtEndRec 0 endrec])
  |    AbsBasilIR.AddrAttrNone  -> prPrec i 0 (concatD [])
  |    AbsBasilIR.AddrAttrEmpty (beginrec, endrec) -> prPrec i 0 (concatD [prtBeginRec 0 beginrec ; prtEndRec 0 endrec])


and prtEndian (i:int) (e : AbsBasilIR.endian) : doc = match e with
       AbsBasilIR.LittleEndian  -> prPrec i 0 (concatD [render "le"])
  |    AbsBasilIR.BigEndian  -> prPrec i 0 (concatD [render "be"])


and prtStatement (i:int) (e : AbsBasilIR.statement) : doc = match e with
       AbsBasilIR.Assign (lvar, expr) -> prPrec i 0 (concatD [prtLVar 0 lvar ; render ":=" ; prtExpr 0 expr])
  |    AbsBasilIR.SLoad (lvar, endian, bident, expr, intval) -> prPrec i 0 (concatD [prtLVar 0 lvar ; render ":=" ; render "load" ; prtEndian 0 endian ; prtBIdent 0 bident ; prtExpr 0 expr ; prtIntVal 0 intval])
  |    AbsBasilIR.SStore (endian, bident, expr1, expr2, intval) -> prPrec i 0 (concatD [render "store" ; prtEndian 0 endian ; prtBIdent 0 bident ; prtExpr 0 expr1 ; prtExpr 0 expr2 ; prtIntVal 0 intval])
  |    AbsBasilIR.DirectCall (calllvars, bident, exprs) -> prPrec i 0 (concatD [prtCallLVars 0 calllvars ; render "call" ; prtBIdent 0 bident ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])
  |    AbsBasilIR.IndirectCall expr -> prPrec i 0 (concatD [render "indirect" ; render "call" ; prtExpr 0 expr])
  |    AbsBasilIR.Assume expr -> prPrec i 0 (concatD [render "assume" ; prtExpr 0 expr])
  |    AbsBasilIR.Assert expr -> prPrec i 0 (concatD [render "assert" ; prtExpr 0 expr])

and prtStatementListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtStatement 0 x ; render ";" ; prtStatementListBNFC 0 xs])
and prtCallLVars (i:int) (e : AbsBasilIR.callLVars) : doc = match e with
       AbsBasilIR.NoOutParams  -> prPrec i 0 (concatD [])
  |    AbsBasilIR.LocalVars lvars -> prPrec i 0 (concatD [render "var" ; render "(" ; prtLVarListBNFC 0 lvars ; render ")" ; render ":="])
  |    AbsBasilIR.ListOutParams lvars -> prPrec i 0 (concatD [render "(" ; prtLVarListBNFC 0 lvars ; render ")" ; render ":="])


and prtJump (i:int) (e : AbsBasilIR.jump) : doc = match e with
       AbsBasilIR.GoTo bidents -> prPrec i 0 (concatD [render "goto" ; render "(" ; prtBIdentListBNFC 0 bidents ; render ")"])
  |    AbsBasilIR.Unreachable  -> prPrec i 0 (concatD [render "unreachable"])
  |    AbsBasilIR.Return exprs -> prPrec i 0 (concatD [render "return" ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])


and prtLVar (i:int) (e : AbsBasilIR.lVar) : doc = match e with
       AbsBasilIR.LVarDef (bident, type_) -> prPrec i 0 (concatD [render "var" ; prtBIdent 0 bident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.GlobalLVar (bident, type_) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render ":" ; prtTypeT 0 type_])

and prtLVarListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtLVar 0 x])
  | (_,x::xs) -> (concatD [prtLVar 0 x ; render "," ; prtLVarListBNFC 0 xs])
and prtBlock (i:int) (e : AbsBasilIR.block) : doc = match e with
       AbsBasilIR.B (bident, addrattr, beginlist, statements, jump, endlist) -> prPrec i 0 (concatD [render "block" ; prtBIdent 0 bident ; prtAddrAttr 0 addrattr ; prtBeginList 0 beginlist ; prtStatementListBNFC 0 statements ; prtJump 0 jump ; prtEndList 0 endlist])

and prtBlockListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtBlock 0 x])
  | (_,x::xs) -> (concatD [prtBlock 0 x ; render ";" ; prtBlockListBNFC 0 xs])
and prtPEntry (i:int) (e : AbsBasilIR.pEntry) : doc = match e with
       AbsBasilIR.EntrySome str -> prPrec i 0 (concatD [render "entry_block" ; render "=" ; prtStr 0 str ; render ";"])
  |    AbsBasilIR.EntryNone  -> prPrec i 0 (concatD [])


and prtPAddress (i:int) (e : AbsBasilIR.pAddress) : doc = match e with
       AbsBasilIR.AddrSome intval -> prPrec i 0 (concatD [render "address" ; render "=" ; prtIntVal 0 intval ; render ";"])
  |    AbsBasilIR.AddrNone  -> prPrec i 0 (concatD [])


and prtInternalBlocks (i:int) (e : AbsBasilIR.internalBlocks) : doc = match e with
       AbsBasilIR.BSome (beginlist, blocks, endlist) -> prPrec i 0 (concatD [render "blocks" ; render "=" ; prtBeginList 0 beginlist ; prtBlockListBNFC 0 blocks ; prtEndList 0 endlist ; render ";"])
  |    AbsBasilIR.BNone  -> prPrec i 0 (concatD [])


and prtProcDef (i:int) (e : AbsBasilIR.procDef) : doc = match e with
       AbsBasilIR.PD (beginrec, str, paddress, pentry, internalblocks, endrec) -> prPrec i 0 (concatD [prtBeginRec 0 beginrec ; render "name" ; render "=" ; prtStr 0 str ; render ";" ; prtPAddress 0 paddress ; prtPEntry 0 pentry ; prtInternalBlocks 0 internalblocks ; prtEndRec 0 endrec])


and prtParams (i:int) (e : AbsBasilIR.params) : doc = match e with
       AbsBasilIR.Param (bident, type_) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render ":" ; prtTypeT 0 type_])

and prtParamsListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtParams 0 x])
  | (_,x::xs) -> (concatD [prtParams 0 x ; render "," ; prtParamsListBNFC 0 xs])
and prtExpr (i:int) (e : AbsBasilIR.expr) : doc = match e with
       AbsBasilIR.RVar (bident, type_) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.BinaryExpr (binop, expr1, expr2) -> prPrec i 0 (concatD [prtBinOp 0 binop ; render "(" ; prtExpr 0 expr1 ; render "," ; prtExpr 0 expr2 ; render ")"])
  |    AbsBasilIR.UnaryExpr (unop, expr) -> prPrec i 0 (concatD [prtUnOp 0 unop ; render "(" ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.ZeroExtend (intval, expr) -> prPrec i 0 (concatD [render "zero_extend" ; render "(" ; prtIntVal 0 intval ; render "," ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.SignExtend (intval, expr) -> prPrec i 0 (concatD [render "sign_extend" ; render "(" ; prtIntVal 0 intval ; render "," ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.Extract (intval1, intval2, expr) -> prPrec i 0 (concatD [render "extract" ; render "(" ; prtIntVal 0 intval1 ; render "," ; prtIntVal 0 intval2 ; render "," ; prtExpr 0 expr ; render ")"])
  |    AbsBasilIR.Concat (expr1, expr2) -> prPrec i 0 (concatD [render "bvconcat" ; render "(" ; prtExpr 0 expr1 ; render "," ; prtExpr 0 expr2 ; render ")"])
  |    AbsBasilIR.BVLiteral (intval, bvtype) -> prPrec i 0 (concatD [prtIntVal 0 intval ; render ":" ; prtBVType 0 bvtype])
  |    AbsBasilIR.IntLiteral intval -> prPrec i 0 (concatD [prtIntVal 0 intval])
  |    AbsBasilIR.TrueLiteral  -> prPrec i 0 (concatD [render "true"])
  |    AbsBasilIR.FalseLiteral  -> prPrec i 0 (concatD [render "false"])

and prtExprListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtExpr 0 x])
  | (_,x::xs) -> (concatD [prtExpr 0 x ; render "," ; prtExprListBNFC 0 xs])
and prtBinOp (i:int) (e : AbsBasilIR.binOp) : doc = match e with
       AbsBasilIR.BinOpBVBinOp bvbinop -> prPrec i 0 (concatD [prtBVBinOp 0 bvbinop])
  |    AbsBasilIR.BinOpBVLogicalBinOp bvlogicalbinop -> prPrec i 0 (concatD [prtBVLogicalBinOp 0 bvlogicalbinop])
  |    AbsBasilIR.BinOpBoolBinOp boolbinop -> prPrec i 0 (concatD [prtBoolBinOp 0 boolbinop])
  |    AbsBasilIR.BinOpIntLogicalBinOp intlogicalbinop -> prPrec i 0 (concatD [prtIntLogicalBinOp 0 intlogicalbinop])
  |    AbsBasilIR.BinOpIntBinOp intbinop -> prPrec i 0 (concatD [prtIntBinOp 0 intbinop])


and prtUnOp (i:int) (e : AbsBasilIR.unOp) : doc = match e with
       AbsBasilIR.UnOpBVUnOp bvunop -> prPrec i 0 (concatD [prtBVUnOp 0 bvunop])
  |    AbsBasilIR.UnOp_boolnot  -> prPrec i 0 (concatD [render "boolnot"])
  |    AbsBasilIR.UnOp_intneg  -> prPrec i 0 (concatD [render "intneg"])


and prtBVUnOp (i:int) (e : AbsBasilIR.bVUnOp) : doc = match e with
       AbsBasilIR.BVUnOp_bvnot  -> prPrec i 0 (concatD [render "bvnot"])
  |    AbsBasilIR.BVUnOp_bvneg  -> prPrec i 0 (concatD [render "bvneg"])


and prtBVBinOp (i:int) (e : AbsBasilIR.bVBinOp) : doc = match e with
       AbsBasilIR.BVBinOp_bvand  -> prPrec i 0 (concatD [render "bvand"])
  |    AbsBasilIR.BVBinOp_bvor  -> prPrec i 0 (concatD [render "bvor"])
  |    AbsBasilIR.BVBinOp_bvadd  -> prPrec i 0 (concatD [render "bvadd"])
  |    AbsBasilIR.BVBinOp_bvmul  -> prPrec i 0 (concatD [render "bvmul"])
  |    AbsBasilIR.BVBinOp_bvudiv  -> prPrec i 0 (concatD [render "bvudiv"])
  |    AbsBasilIR.BVBinOp_bvurem  -> prPrec i 0 (concatD [render "bvurem"])
  |    AbsBasilIR.BVBinOp_bvshl  -> prPrec i 0 (concatD [render "bvshl"])
  |    AbsBasilIR.BVBinOp_bvlshr  -> prPrec i 0 (concatD [render "bvlshr"])
  |    AbsBasilIR.BVBinOp_bvult  -> prPrec i 0 (concatD [render "bvult"])
  |    AbsBasilIR.BVBinOp_bvnand  -> prPrec i 0 (concatD [render "bvnand"])
  |    AbsBasilIR.BVBinOp_bvnor  -> prPrec i 0 (concatD [render "bvnor"])
  |    AbsBasilIR.BVBinOp_bvxor  -> prPrec i 0 (concatD [render "bvxor"])
  |    AbsBasilIR.BVBinOp_bvxnor  -> prPrec i 0 (concatD [render "bvxnor"])
  |    AbsBasilIR.BVBinOp_bvcomp  -> prPrec i 0 (concatD [render "bvcomp"])
  |    AbsBasilIR.BVBinOp_bvsub  -> prPrec i 0 (concatD [render "bvsub"])
  |    AbsBasilIR.BVBinOp_bvsdiv  -> prPrec i 0 (concatD [render "bvsdiv"])
  |    AbsBasilIR.BVBinOp_bvsrem  -> prPrec i 0 (concatD [render "bvsrem"])
  |    AbsBasilIR.BVBinOp_bvsmod  -> prPrec i 0 (concatD [render "bvsmod"])
  |    AbsBasilIR.BVBinOp_bvashr  -> prPrec i 0 (concatD [render "bvashr"])


and prtBVLogicalBinOp (i:int) (e : AbsBasilIR.bVLogicalBinOp) : doc = match e with
       AbsBasilIR.BVLogicalBinOp_bvule  -> prPrec i 0 (concatD [render "bvule"])
  |    AbsBasilIR.BVLogicalBinOp_bvugt  -> prPrec i 0 (concatD [render "bvugt"])
  |    AbsBasilIR.BVLogicalBinOp_bvuge  -> prPrec i 0 (concatD [render "bvuge"])
  |    AbsBasilIR.BVLogicalBinOp_bvslt  -> prPrec i 0 (concatD [render "bvslt"])
  |    AbsBasilIR.BVLogicalBinOp_bvsle  -> prPrec i 0 (concatD [render "bvsle"])
  |    AbsBasilIR.BVLogicalBinOp_bvsgt  -> prPrec i 0 (concatD [render "bvsgt"])
  |    AbsBasilIR.BVLogicalBinOp_bvsge  -> prPrec i 0 (concatD [render "bvsge"])
  |    AbsBasilIR.BVLogicalBinOp_bveq  -> prPrec i 0 (concatD [render "bveq"])
  |    AbsBasilIR.BVLogicalBinOp_bvneq  -> prPrec i 0 (concatD [render "bvneq"])


and prtIntBinOp (i:int) (e : AbsBasilIR.intBinOp) : doc = match e with
       AbsBasilIR.IntBinOp_intadd  -> prPrec i 0 (concatD [render "intadd"])
  |    AbsBasilIR.IntBinOp_intmul  -> prPrec i 0 (concatD [render "intmul"])
  |    AbsBasilIR.IntBinOp_intsub  -> prPrec i 0 (concatD [render "intsub"])
  |    AbsBasilIR.IntBinOp_intdiv  -> prPrec i 0 (concatD [render "intdiv"])
  |    AbsBasilIR.IntBinOp_intmod  -> prPrec i 0 (concatD [render "intmod"])


and prtIntLogicalBinOp (i:int) (e : AbsBasilIR.intLogicalBinOp) : doc = match e with
       AbsBasilIR.IntLogicalBinOp_inteq  -> prPrec i 0 (concatD [render "inteq"])
  |    AbsBasilIR.IntLogicalBinOp_intneq  -> prPrec i 0 (concatD [render "intneq"])
  |    AbsBasilIR.IntLogicalBinOp_intlt  -> prPrec i 0 (concatD [render "intlt"])
  |    AbsBasilIR.IntLogicalBinOp_intle  -> prPrec i 0 (concatD [render "intle"])
  |    AbsBasilIR.IntLogicalBinOp_intgt  -> prPrec i 0 (concatD [render "intgt"])
  |    AbsBasilIR.IntLogicalBinOp_intge  -> prPrec i 0 (concatD [render "intge"])


and prtBoolBinOp (i:int) (e : AbsBasilIR.boolBinOp) : doc = match e with
       AbsBasilIR.BoolBinOp_booleq  -> prPrec i 0 (concatD [render "booleq"])
  |    AbsBasilIR.BoolBinOp_boolneq  -> prPrec i 0 (concatD [render "boolneq"])
  |    AbsBasilIR.BoolBinOp_booland  -> prPrec i 0 (concatD [render "booland"])
  |    AbsBasilIR.BoolBinOp_boolor  -> prPrec i 0 (concatD [render "boolor"])
  |    AbsBasilIR.BoolBinOp_boolimplies  -> prPrec i 0 (concatD [render "boolimplies"])
  |    AbsBasilIR.BoolBinOp_boolequiv  -> prPrec i 0 (concatD [render "boolequiv"])




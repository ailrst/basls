(* File generated by the BNF Converter (bnfc 2.9.5). *)

(* pretty-printer *)

open Printf

(* We use string buffers for efficient string concatenation.
   A document takes a buffer and an indentation, has side effects on the buffer
   and returns a new indentation. The indentation argument indicates the level
   of indentation to be used if a new line has to be started (because of what is
   already in the buffer) *)
type doc = Buffer.t -> int -> int

let rec printTree (printer : int -> 'a -> doc) (tree : 'a) : string =
    let buffer_init_size = 64 (* you may want to change this *)
    in let buffer = Buffer.create buffer_init_size
    in
        let _ = printer 0 tree buffer 0 in (* discard return value *)
        Buffer.contents buffer

let indent_width = 2

let spaces (i: int) : string = if i > 0 then String.make i ' ' else ""
let indent (i: int) : string = "\n" ^ spaces i

(* To avoid dependency on package extlib, which has
   Extlib.ExtChar.Char.is_whitespace, we employ the following awkward
   way to check a character for whitespace.
   Note: String.trim exists in the core libraries since Ocaml 4.00. *)
let isWhiteSpace (c: char) : bool = String.trim (String.make 1 c) = ""

(* this render function is written for C-style languages, you may want to change it *)
let render (s : string) : doc = fun buf i ->
    (* invariant: last char of the buffer is never whitespace *)
    let n = Buffer.length buf in
    let last = if n = 0 then None else Some (Buffer.nth buf (n-1)) in
    let newindent = match s with
        "{" -> i + indent_width
      | "}" -> i - indent_width
      | _ -> i in
    let whitespace = match last with
        None -> ""
      | Some '}' -> (match s with
            ";" -> ""
          | _ -> indent newindent)
      | (Some '{') | (Some ';') -> if s = "}" then indent newindent else indent i
      | (Some '[') | (Some '(') -> ""
      | Some c -> if isWhiteSpace c then "" else (match s with
             ";" | "," | ")" | "]" -> ""
           | "{" -> indent i
           | "}" -> indent newindent
           | _ -> if String.trim s = "" then "" else " ") in
    Buffer.add_string buf whitespace;
    Buffer.add_string buf s;
    newindent

let emptyDoc : doc = fun buf i -> i

let concatD (ds : doc list) : doc = fun buf i ->
    List.fold_left (fun accIndent elemDoc -> elemDoc buf accIndent) (emptyDoc buf i) ds

let parenth (d:doc) : doc = concatD [render "("; d; render ")"]

let prPrec (i:int) (j:int) (d:doc) : doc = if j<i then parenth d else d


let prtChar (_:int) (c:char) : doc = render ("'" ^ Char.escaped c ^ "'")



let prtInt (_:int) (i:int) : doc = render (string_of_int i)



let prtFloat (_:int) (f:float) : doc = render (sprintf "%.15g" f)



let prtString (_:int) (s:string) : doc = render ("\"" ^ String.escaped s ^ "\"")




let prtBVTYPE _ (AbsBasilIR.BVTYPE i) : doc = render i


let prtBIdent _ (AbsBasilIR.BIdent (_,i)) : doc = render i
let rec prtBIdentListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtBIdent 0 x])
  | (_,x::xs) -> (concatD [prtBIdent 0 x ; render "," ; prtBIdentListBNFC 0 xs])

let prtStr _ (AbsBasilIR.Str i) : doc = render i


let prtIntegerHex _ (AbsBasilIR.IntegerHex i) : doc = render i



let rec prtProgram (i:int) (e : AbsBasilIR.program) : doc = match e with
       AbsBasilIR.Prog declarations -> prPrec i 0 (concatD [prtDeclarationListBNFC 0 declarations])


and prtDeclaration (i:int) (e : AbsBasilIR.declaration) : doc = match e with
       AbsBasilIR.LetDecl (bident, mexpr) -> prPrec i 0 (concatD [render "let" ; prtBIdent 0 bident ; render "=" ; prtMExpr 0 mexpr])
  |    AbsBasilIR.MemDecl (bident, type_) -> prPrec i 0 (concatD [render "memory" ; prtBIdent 0 bident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.VarDecl (bident, type_) -> prPrec i 0 (concatD [render "var" ; prtBIdent 0 bident ; render ":" ; prtTypeT 0 type_])
  |    AbsBasilIR.Procedure (bident, paramss1, paramss2, procdef) -> prPrec i 0 (concatD [render "proc" ; prtBIdent 0 bident ; render "(" ; prtParamsListBNFC 0 paramss1 ; render ")" ; render "->" ; render "(" ; prtParamsListBNFC 0 paramss2 ; render ")" ; prtProcDef 0 procdef])

and prtDeclarationListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtDeclaration 0 x])
  | (_,x::xs) -> (concatD [prtDeclaration 0 x ; render ";" ; prtDeclarationListBNFC 0 xs])
and prtMExpr (i:int) (e : AbsBasilIR.mExpr) : doc = match e with
       AbsBasilIR.MSym bident -> prPrec i 0 (concatD [prtBIdent 0 bident])
  |    AbsBasilIR.BlockM block -> prPrec i 0 (concatD [prtBlock 0 block])


and prtIntType (i:int) (e : AbsBasilIR.intType) : doc = match e with
       AbsBasilIR.IntT  -> prPrec i 0 (concatD [render "int"])


and prtBoolType (i:int) (e : AbsBasilIR.boolType) : doc = match e with
       AbsBasilIR.BoolT  -> prPrec i 0 (concatD [render "bool"])


and prtMapType (i:int) (e : AbsBasilIR.mapType) : doc = match e with
       AbsBasilIR.MapT (type_1, type_2) -> prPrec i 0 (concatD [render "map" ; prtTypeT 0 type_1 ; render "[" ; prtTypeT 0 type_2 ; render "]"])


and prtBVType (i:int) (e : AbsBasilIR.bVType) : doc = match e with
       AbsBasilIR.ShortBVT bvtype -> prPrec i 0 (concatD [prtBVTYPE 0 bvtype])
  |    AbsBasilIR.BitvectorType intlit -> prPrec i 0 (concatD [render "bv" ; prtIntLit 0 intlit])


and prtTypeT (i:int) (e : AbsBasilIR.typeT) : doc = match e with
       AbsBasilIR.TypeIntType inttype -> prPrec i 0 (concatD [prtIntType 0 inttype])
  |    AbsBasilIR.TypeBoolType booltype -> prPrec i 0 (concatD [prtBoolType 0 booltype])
  |    AbsBasilIR.TypeMapType maptype -> prPrec i 0 (concatD [prtMapType 0 maptype])
  |    AbsBasilIR.TypeBVType bvtype -> prPrec i 0 (concatD [prtBVType 0 bvtype])


and prtIntLit (i:int) (e : AbsBasilIR.intLit) : doc = match e with
       AbsBasilIR.HexInt integerhex -> prPrec i 0 (concatD [prtIntegerHex 0 integerhex])
  |    AbsBasilIR.DecInt integer -> prPrec i 0 (concatD [prtInt 0 integer])


and prtAddrAttr (i:int) (e : AbsBasilIR.addrAttr) : doc = match e with
       AbsBasilIR.AddrAttrSome intlit -> prPrec i 0 (concatD [render "{" ; render "address" ; render "=" ; prtIntLit 0 intlit ; render "}"])
  |    AbsBasilIR.AddrAttrNone  -> prPrec i 0 (concatD [])
  |    AbsBasilIR.AddrAttrEmpty  -> prPrec i 0 (concatD [render "{" ; render "}"])


and prtEndian (i:int) (e : AbsBasilIR.endian) : doc = match e with
       AbsBasilIR.LittleEndian  -> prPrec i 0 (concatD [render "le"])
  |    AbsBasilIR.BigEndian  -> prPrec i 0 (concatD [render "be"])


and prtStatement (i:int) (e : AbsBasilIR.statement) : doc = match e with
       AbsBasilIR.AssignStmt assign -> prPrec i 0 (concatD [prtAssign 0 assign])
  |    AbsBasilIR.SLoad (bvlvar, endian, bident, bvexpr, intlit) -> prPrec i 0 (concatD [prtBVLVar 0 bvlvar ; render ":=" ; render "load" ; prtEndian 0 endian ; prtBIdent 0 bident ; prtBVExpr 0 bvexpr ; prtIntLit 0 intlit])
  |    AbsBasilIR.SStore (endian, bident, expr, bvexpr, intlit) -> prPrec i 0 (concatD [render "store" ; prtEndian 0 endian ; prtBIdent 0 bident ; prtExpr 0 expr ; prtBVExpr 0 bvexpr ; prtIntLit 0 intlit])
  |    AbsBasilIR.DirectCall (bident, exprs) -> prPrec i 0 (concatD [render "call" ; prtBIdent 0 bident ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])
  |    AbsBasilIR.DirectCallReturnLocal (lvars, bident, exprs) -> prPrec i 0 (concatD [render "var" ; render "(" ; prtLVarListBNFC 0 lvars ; render ")" ; render ":=" ; render "call" ; prtBIdent 0 bident ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])
  |    AbsBasilIR.DirectCallReturn (lvars, bident, exprs) -> prPrec i 0 (concatD [render "(" ; prtLVarListBNFC 0 lvars ; render ")" ; render ":=" ; render "call" ; prtBIdent 0 bident ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])
  |    AbsBasilIR.IndirectCall expr -> prPrec i 0 (concatD [render "indirect" ; render "call" ; prtExpr 0 expr])
  |    AbsBasilIR.Assume expr -> prPrec i 0 (concatD [render "assume" ; prtExpr 0 expr])
  |    AbsBasilIR.Assert expr -> prPrec i 0 (concatD [render "assert" ; prtExpr 0 expr])

and prtStatementListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtStatement 0 x ; render ";" ; prtStatementListBNFC 0 xs])
and prtAssign (i:int) (e : AbsBasilIR.assign) : doc = match e with
       AbsBasilIR.IntAssign (intlvar, intexpr) -> prPrec i 0 (concatD [prtIntLVar 0 intlvar ; render ":=" ; prtIntExpr 0 intexpr])
  |    AbsBasilIR.BVAssign (bvlvar, bvexpr) -> prPrec i 0 (concatD [prtBVLVar 0 bvlvar ; render ":=" ; prtBVExpr 0 bvexpr])
  |    AbsBasilIR.BoolAssign (boollvar, logexpr) -> prPrec i 0 (concatD [prtBoolLVar 0 boollvar ; render ":=" ; prtLogExpr 0 logexpr])


and prtJump (i:int) (e : AbsBasilIR.jump) : doc = match e with
       AbsBasilIR.GoTo bidents -> prPrec i 0 (concatD [render "goto" ; render "(" ; prtBIdentListBNFC 0 bidents ; render ")"])
  |    AbsBasilIR.Unreachable  -> prPrec i 0 (concatD [render "unreachable"])
  |    AbsBasilIR.Return exprs -> prPrec i 0 (concatD [render "return" ; render "(" ; prtExprListBNFC 0 exprs ; render ")"])


and prtLVar (i:int) (e : AbsBasilIR.lVar) : doc = match e with
       AbsBasilIR.LVarIntLVar intlvar -> prPrec i 0 (concatD [prtIntLVar 0 intlvar])
  |    AbsBasilIR.LVarBVLVar bvlvar -> prPrec i 0 (concatD [prtBVLVar 0 bvlvar])
  |    AbsBasilIR.LVarBoolLVar boollvar -> prPrec i 0 (concatD [prtBoolLVar 0 boollvar])

and prtLVarListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtLVar 0 x])
  | (_,x::xs) -> (concatD [prtLVar 0 x ; render "," ; prtLVarListBNFC 0 xs])
and prtBVLVar (i:int) (e : AbsBasilIR.bVLVar) : doc = match e with
       AbsBasilIR.LocalBVLVar (bident, bvtype) -> prPrec i 0 (concatD [render "var" ; prtBIdent 0 bident ; render ":" ; prtBVType 0 bvtype])
  |    AbsBasilIR.GlobalBVLVar (bident, bvtype) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render ":" ; prtBVType 0 bvtype])


and prtIntLVar (i:int) (e : AbsBasilIR.intLVar) : doc = match e with
       AbsBasilIR.LocalIntLVar (bident, inttype) -> prPrec i 0 (concatD [render "var" ; prtBIdent 0 bident ; render ":" ; prtIntType 0 inttype])
  |    AbsBasilIR.GlobalIntLVar (bident, inttype) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render ":" ; prtIntType 0 inttype])


and prtBoolLVar (i:int) (e : AbsBasilIR.boolLVar) : doc = match e with
       AbsBasilIR.LocalBoolLVar (bident, booltype) -> prPrec i 0 (concatD [render "var" ; prtBIdent 0 bident ; render ":" ; prtBoolType 0 booltype])
  |    AbsBasilIR.GlobalBoolLVar (bident, booltype) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render ":" ; prtBoolType 0 booltype])


and prtBlock (i:int) (e : AbsBasilIR.block) : doc = match e with
       AbsBasilIR.B (bident, addrattr, statements, jump) -> prPrec i 0 (concatD [render "block" ; prtBIdent 0 bident ; prtAddrAttr 0 addrattr ; render "[" ; prtStatementListBNFC 0 statements ; prtJump 0 jump ; render "]"])

and prtBlockListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtBlock 0 x])
  | (_,x::xs) -> (concatD [prtBlock 0 x ; render ";" ; prtBlockListBNFC 0 xs])
and prtPEntry (i:int) (e : AbsBasilIR.pEntry) : doc = match e with
       AbsBasilIR.EntrySome block -> prPrec i 0 (concatD [render "entry" ; render "=" ; prtBlock 0 block ; render ";"])
  |    AbsBasilIR.EntryNone  -> prPrec i 0 (concatD [])


and prtPExit (i:int) (e : AbsBasilIR.pExit) : doc = match e with
       AbsBasilIR.ESome block -> prPrec i 0 (concatD [render "exit" ; render "=" ; prtBlock 0 block ; render ";"])
  |    AbsBasilIR.ENone  -> prPrec i 0 (concatD [])


and prtPAddress (i:int) (e : AbsBasilIR.pAddress) : doc = match e with
       AbsBasilIR.AddrSome intlit -> prPrec i 0 (concatD [render "address" ; render "=" ; prtIntLit 0 intlit ; render ";"])
  |    AbsBasilIR.AddrNone  -> prPrec i 0 (concatD [])


and prtInternalBlocks (i:int) (e : AbsBasilIR.internalBlocks) : doc = match e with
       AbsBasilIR.BSome blocks -> prPrec i 0 (concatD [render "blocks" ; render "=" ; render "[" ; prtBlockListBNFC 0 blocks ; render "]" ; render ";"])
  |    AbsBasilIR.BNone  -> prPrec i 0 (concatD [])


and prtProcDef (i:int) (e : AbsBasilIR.procDef) : doc = match e with
       AbsBasilIR.PD (str, paddress, pentry, pexit, internalblocks) -> prPrec i 0 (concatD [render "{" ; render "name" ; render "=" ; prtStr 0 str ; render ";" ; prtPAddress 0 paddress ; prtPEntry 0 pentry ; prtPExit 0 pexit ; prtInternalBlocks 0 internalblocks ; render "}"])


and prtParams (i:int) (e : AbsBasilIR.params) : doc = match e with
       AbsBasilIR.Param (bident, type_) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render ":" ; prtTypeT 0 type_])

and prtParamsListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtParams 0 x])
  | (_,x::xs) -> (concatD [prtParams 0 x ; render "," ; prtParamsListBNFC 0 xs])
and prtExpr (i:int) (e : AbsBasilIR.expr) : doc = match e with
       AbsBasilIR.BitvectorExpr bvexpr -> prPrec i 0 (concatD [prtBVExpr 0 bvexpr])
  |    AbsBasilIR.LogicalExpr logexpr -> prPrec i 0 (concatD [prtLogExpr 0 logexpr])
  |    AbsBasilIR.IntegerExpr intexpr -> prPrec i 0 (concatD [prtIntExpr 0 intexpr])

and prtExprListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtExpr 0 x])
  | (_,x::xs) -> (concatD [prtExpr 0 x ; render "," ; prtExprListBNFC 0 xs])
and prtBVExpr (i:int) (e : AbsBasilIR.bVExpr) : doc = match e with
       AbsBasilIR.BVBinary (bvbinop, bvexpr1, bvexpr2) -> prPrec i 0 (concatD [prtBVBinOp 0 bvbinop ; render "(" ; prtBVExpr 0 bvexpr1 ; render "," ; prtBVExpr 0 bvexpr2 ; render ")"])
  |    AbsBasilIR.BVUnary (bvunop, bvexpr) -> prPrec i 0 (concatD [prtBVUnOp 0 bvunop ; render "(" ; prtBVExpr 0 bvexpr ; render ")"])
  |    AbsBasilIR.ZeroExtend (intlit, bvexpr) -> prPrec i 0 (concatD [render "zero_extend" ; render "(" ; prtIntLit 0 intlit ; render "," ; prtBVExpr 0 bvexpr ; render ")"])
  |    AbsBasilIR.SignExtend (intlit, bvexpr) -> prPrec i 0 (concatD [render "sign_extend" ; render "(" ; prtIntLit 0 intlit ; render "," ; prtBVExpr 0 bvexpr ; render ")"])
  |    AbsBasilIR.Extract (intlit1, intlit2, bvexpr) -> prPrec i 0 (concatD [render "extract" ; render "(" ; prtIntLit 0 intlit1 ; render "," ; prtIntLit 0 intlit2 ; render "," ; prtBVExpr 0 bvexpr ; render ")"])
  |    AbsBasilIR.Concat (bvexpr1, bvexpr2) -> prPrec i 0 (concatD [render "bvconcat" ; render "(" ; prtBVExpr 0 bvexpr1 ; render "," ; prtBVExpr 0 bvexpr2 ; render ")"])
  |    AbsBasilIR.BVLiteral (intlit, bvtype) -> prPrec i 0 (concatD [prtIntLit 0 intlit ; render ":" ; prtBVType 0 bvtype])
  |    AbsBasilIR.RBVVar bvrvar -> prPrec i 0 (concatD [prtBVRVar 0 bvrvar])


and prtIntExpr (i:int) (e : AbsBasilIR.intExpr) : doc = match e with
       AbsBasilIR.IntLiteral intlit -> prPrec i 0 (concatD [prtIntLit 0 intlit])
  |    AbsBasilIR.RIntVar intrvar -> prPrec i 0 (concatD [prtIntRVar 0 intrvar])
  |    AbsBasilIR.IntBinary (intbinop, intexpr1, intexpr2) -> prPrec i 0 (concatD [prtIntBinOp 0 intbinop ; render "(" ; prtIntExpr 0 intexpr1 ; render "," ; prtIntExpr 0 intexpr2 ; render ")"])
  |    AbsBasilIR.IntNeg intexpr -> prPrec i 0 (concatD [render "intneg" ; render "(" ; prtIntExpr 0 intexpr ; render ")"])


and prtLogExpr (i:int) (e : AbsBasilIR.logExpr) : doc = match e with
       AbsBasilIR.BVLogBinary (bvlogicalbinop, bvexpr1, bvexpr2) -> prPrec i 0 (concatD [prtBVLogicalBinOp 0 bvlogicalbinop ; render "(" ; prtBVExpr 0 bvexpr1 ; render "," ; prtBVExpr 0 bvexpr2 ; render ")"])
  |    AbsBasilIR.RLogVar boolrvar -> prPrec i 0 (concatD [prtBoolRVar 0 boolrvar])
  |    AbsBasilIR.BoolLit boolliteral -> prPrec i 0 (concatD [prtBoolLiteral 0 boolliteral])
  |    AbsBasilIR.IntLogBinary (intlogicalbinop, intexpr1, intexpr2) -> prPrec i 0 (concatD [prtIntLogicalBinOp 0 intlogicalbinop ; render "(" ; prtIntExpr 0 intexpr1 ; render "," ; prtIntExpr 0 intexpr2 ; render ")"])
  |    AbsBasilIR.BoolLogBinOp (boolbinop, logexpr1, logexpr2) -> prPrec i 0 (concatD [prtBoolBinOp 0 boolbinop ; render "(" ; prtLogExpr 0 logexpr1 ; render "," ; prtLogExpr 0 logexpr2 ; render ")"])
  |    AbsBasilIR.BoolNot logexpr -> prPrec i 0 (concatD [render "boolnot" ; render "(" ; prtLogExpr 0 logexpr ; render ")"])


and prtIntRVar (i:int) (e : AbsBasilIR.intRVar) : doc = match e with
       AbsBasilIR.IRV (bident, inttype) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render ":" ; prtIntType 0 inttype])


and prtBVRVar (i:int) (e : AbsBasilIR.bVRVar) : doc = match e with
       AbsBasilIR.BVRV (bident, bvtype) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render ":" ; prtBVType 0 bvtype])


and prtBoolRVar (i:int) (e : AbsBasilIR.boolRVar) : doc = match e with
       AbsBasilIR.BRV (bident, booltype) -> prPrec i 0 (concatD [prtBIdent 0 bident ; render ":" ; prtBoolType 0 booltype])


and prtBoolLiteral (i:int) (e : AbsBasilIR.boolLiteral) : doc = match e with
       AbsBasilIR.BoolLiteral_true  -> prPrec i 0 (concatD [render "true"])
  |    AbsBasilIR.BoolLiteral_false  -> prPrec i 0 (concatD [render "false"])


and prtBVUnOp (i:int) (e : AbsBasilIR.bVUnOp) : doc = match e with
       AbsBasilIR.BVUnOp_bvnot  -> prPrec i 0 (concatD [render "bvnot"])
  |    AbsBasilIR.BVUnOp_bvneg  -> prPrec i 0 (concatD [render "bvneg"])


and prtBVBinOp (i:int) (e : AbsBasilIR.bVBinOp) : doc = match e with
       AbsBasilIR.BVBinOp_bvand  -> prPrec i 0 (concatD [render "bvand"])
  |    AbsBasilIR.BVBinOp_bvor  -> prPrec i 0 (concatD [render "bvor"])
  |    AbsBasilIR.BVBinOp_bvadd  -> prPrec i 0 (concatD [render "bvadd"])
  |    AbsBasilIR.BVBinOp_bvmul  -> prPrec i 0 (concatD [render "bvmul"])
  |    AbsBasilIR.BVBinOp_bvudiv  -> prPrec i 0 (concatD [render "bvudiv"])
  |    AbsBasilIR.BVBinOp_bvurem  -> prPrec i 0 (concatD [render "bvurem"])
  |    AbsBasilIR.BVBinOp_bvshl  -> prPrec i 0 (concatD [render "bvshl"])
  |    AbsBasilIR.BVBinOp_bvlshr  -> prPrec i 0 (concatD [render "bvlshr"])
  |    AbsBasilIR.BVBinOp_bvnand  -> prPrec i 0 (concatD [render "bvnand"])
  |    AbsBasilIR.BVBinOp_bvnor  -> prPrec i 0 (concatD [render "bvnor"])
  |    AbsBasilIR.BVBinOp_bvxor  -> prPrec i 0 (concatD [render "bvxor"])
  |    AbsBasilIR.BVBinOp_bvxnor  -> prPrec i 0 (concatD [render "bvxnor"])
  |    AbsBasilIR.BVBinOp_bvcomp  -> prPrec i 0 (concatD [render "bvcomp"])
  |    AbsBasilIR.BVBinOp_bvsub  -> prPrec i 0 (concatD [render "bvsub"])
  |    AbsBasilIR.BVBinOp_bvsdiv  -> prPrec i 0 (concatD [render "bvsdiv"])
  |    AbsBasilIR.BVBinOp_bvsrem  -> prPrec i 0 (concatD [render "bvsrem"])
  |    AbsBasilIR.BVBinOp_bvsmod  -> prPrec i 0 (concatD [render "bvsmod"])
  |    AbsBasilIR.BVBinOp_bvashr  -> prPrec i 0 (concatD [render "bvashr"])


and prtBVLogicalBinOp (i:int) (e : AbsBasilIR.bVLogicalBinOp) : doc = match e with
       AbsBasilIR.BVLogicalBinOp_bvule  -> prPrec i 0 (concatD [render "bvule"])
  |    AbsBasilIR.BVLogicalBinOp_bvugt  -> prPrec i 0 (concatD [render "bvugt"])
  |    AbsBasilIR.BVLogicalBinOp_bvuge  -> prPrec i 0 (concatD [render "bvuge"])
  |    AbsBasilIR.BVLogicalBinOp_bvslt  -> prPrec i 0 (concatD [render "bvslt"])
  |    AbsBasilIR.BVLogicalBinOp_bvsle  -> prPrec i 0 (concatD [render "bvsle"])
  |    AbsBasilIR.BVLogicalBinOp_bvsgt  -> prPrec i 0 (concatD [render "bvsgt"])
  |    AbsBasilIR.BVLogicalBinOp_bvsge  -> prPrec i 0 (concatD [render "bvsge"])
  |    AbsBasilIR.BVLogicalBinOp_bveq  -> prPrec i 0 (concatD [render "bveq"])
  |    AbsBasilIR.BVLogicalBinOp_bvneq  -> prPrec i 0 (concatD [render "bvneq"])
  |    AbsBasilIR.BVLogicalBinOp_bvult  -> prPrec i 0 (concatD [render "bvult"])


and prtIntBinOp (i:int) (e : AbsBasilIR.intBinOp) : doc = match e with
       AbsBasilIR.IntBinOp_intadd  -> prPrec i 0 (concatD [render "intadd"])
  |    AbsBasilIR.IntBinOp_intmul  -> prPrec i 0 (concatD [render "intmul"])
  |    AbsBasilIR.IntBinOp_intsub  -> prPrec i 0 (concatD [render "intsub"])
  |    AbsBasilIR.IntBinOp_intdiv  -> prPrec i 0 (concatD [render "intdiv"])
  |    AbsBasilIR.IntBinOp_intmod  -> prPrec i 0 (concatD [render "intmod"])


and prtIntLogicalBinOp (i:int) (e : AbsBasilIR.intLogicalBinOp) : doc = match e with
       AbsBasilIR.IntLogicalBinOp_inteq  -> prPrec i 0 (concatD [render "inteq"])
  |    AbsBasilIR.IntLogicalBinOp_intneq  -> prPrec i 0 (concatD [render "intneq"])
  |    AbsBasilIR.IntLogicalBinOp_intlt  -> prPrec i 0 (concatD [render "intlt"])
  |    AbsBasilIR.IntLogicalBinOp_intle  -> prPrec i 0 (concatD [render "intle"])
  |    AbsBasilIR.IntLogicalBinOp_intgt  -> prPrec i 0 (concatD [render "intgt"])
  |    AbsBasilIR.IntLogicalBinOp_intge  -> prPrec i 0 (concatD [render "intge"])


and prtBoolBinOp (i:int) (e : AbsBasilIR.boolBinOp) : doc = match e with
       AbsBasilIR.BoolBinOp_booleq  -> prPrec i 0 (concatD [render "booleq"])
  |    AbsBasilIR.BoolBinOp_boolneq  -> prPrec i 0 (concatD [render "boolneq"])
  |    AbsBasilIR.BoolBinOp_booland  -> prPrec i 0 (concatD [render "booland"])
  |    AbsBasilIR.BoolBinOp_boolor  -> prPrec i 0 (concatD [render "boolor"])
  |    AbsBasilIR.BoolBinOp_boolimplies  -> prPrec i 0 (concatD [render "boolimplies"])
  |    AbsBasilIR.BoolBinOp_boolequiv  -> prPrec i 0 (concatD [render "boolequiv"])




/* File generated by the BNF Converter (bnfc 2.9.5). */

/* Parser definition for use with menhir */

%{
open AbsBasilIR
open Lexing
%}

%token KW_let KW_memory KW_var KW_int KW_bool KW_map KW_bv KW_address KW_le KW_be KW_load KW_store KW_call KW_indirect KW_assume KW_assert KW_goto KW_unreachable KW_return KW_block KW_entry KW_exit KW_blocks KW_name KW_proc KW_zero_extend KW_sign_extend KW_extract KW_bvconcat KW_true KW_false KW_bvnot KW_bvneg KW_bvand KW_bvor KW_bvadd KW_bvmul KW_bvudiv KW_bvurem KW_bvshl KW_bvlshr KW_bvnand KW_bvnor KW_bvxor KW_bvxnor KW_bvcomp KW_bvsub KW_bvsdiv KW_bvsrem KW_bvsmod KW_bvashr KW_bvule KW_bvugt KW_bvuge KW_bvslt KW_bvsle KW_bvsgt KW_bvsge KW_bveq KW_bvneq KW_bvult KW_intadd KW_intmul KW_intsub KW_intdiv KW_intmod KW_inteq KW_intneq KW_intlt KW_intle KW_intgt KW_intge KW_booleq KW_boolneq KW_booland KW_boolor KW_boolimplies KW_boolequiv KW_intneg KW_boolnot

%token SYMB1 /* ; */
%token SYMB2 /* , */
%token SYMB3 /* = */
%token SYMB4 /* : */
%token SYMB5 /* [ */
%token SYMB6 /* ] */
%token SYMB7 /* { */
%token SYMB8 /* } */
%token SYMB9 /* := */
%token SYMB10 /* ( */
%token SYMB11 /* ) */
%token SYMB12 /* -> */

%token TOK_EOF
%token <string> TOK_Ident
%token <char>   TOK_Char
%token <float>  TOK_Double
%token <int>    TOK_Integer
%token <string> TOK_String
%token <string>               TOK_BVTYPE
%token <(int * int) * string> TOK_BIdent
%token <string>               TOK_Str
%token <string>               TOK_IntegerHex

%start pProgram pDeclaration_list pBIdent_list pDeclaration pMExpr pIntType pBoolType pMapType pBVType pTypeT pExpr_list pIntLit pAddrAttr pEndian pStatement_list pStatement pAssign pJump pLVar pBVLVar pIntLVar pBoolLVar pLVar_list pBlock_list pBlock pPEntry pPExit pPAddress pInternalBlocks pProcDef pParams pParams_list pExpr pBVExpr pIntExpr pLogExpr pIntRVar pBVRVar pBoolRVar pBoolLiteral pBVUnOp pBVBinOp pBVLogicalBinOp pIntBinOp pIntLogicalBinOp pBoolBinOp
%type <AbsBasilIR.program> pProgram
%type <AbsBasilIR.declaration list> pDeclaration_list
%type <AbsBasilIR.bIdent list> pBIdent_list
%type <AbsBasilIR.declaration> pDeclaration
%type <AbsBasilIR.mExpr> pMExpr
%type <AbsBasilIR.intType> pIntType
%type <AbsBasilIR.boolType> pBoolType
%type <AbsBasilIR.mapType> pMapType
%type <AbsBasilIR.bVType> pBVType
%type <AbsBasilIR.typeT> pTypeT
%type <AbsBasilIR.expr list> pExpr_list
%type <AbsBasilIR.intLit> pIntLit
%type <AbsBasilIR.addrAttr> pAddrAttr
%type <AbsBasilIR.endian> pEndian
%type <AbsBasilIR.statement list> pStatement_list
%type <AbsBasilIR.statement> pStatement
%type <AbsBasilIR.assign> pAssign
%type <AbsBasilIR.jump> pJump
%type <AbsBasilIR.lVar> pLVar
%type <AbsBasilIR.bVLVar> pBVLVar
%type <AbsBasilIR.intLVar> pIntLVar
%type <AbsBasilIR.boolLVar> pBoolLVar
%type <AbsBasilIR.lVar list> pLVar_list
%type <AbsBasilIR.block list> pBlock_list
%type <AbsBasilIR.block> pBlock
%type <AbsBasilIR.pEntry> pPEntry
%type <AbsBasilIR.pExit> pPExit
%type <AbsBasilIR.pAddress> pPAddress
%type <AbsBasilIR.internalBlocks> pInternalBlocks
%type <AbsBasilIR.procDef> pProcDef
%type <AbsBasilIR.params> pParams
%type <AbsBasilIR.params list> pParams_list
%type <AbsBasilIR.expr> pExpr
%type <AbsBasilIR.bVExpr> pBVExpr
%type <AbsBasilIR.intExpr> pIntExpr
%type <AbsBasilIR.logExpr> pLogExpr
%type <AbsBasilIR.intRVar> pIntRVar
%type <AbsBasilIR.bVRVar> pBVRVar
%type <AbsBasilIR.boolRVar> pBoolRVar
%type <AbsBasilIR.boolLiteral> pBoolLiteral
%type <AbsBasilIR.bVUnOp> pBVUnOp
%type <AbsBasilIR.bVBinOp> pBVBinOp
%type <AbsBasilIR.bVLogicalBinOp> pBVLogicalBinOp
%type <AbsBasilIR.intBinOp> pIntBinOp
%type <AbsBasilIR.intLogicalBinOp> pIntLogicalBinOp
%type <AbsBasilIR.boolBinOp> pBoolBinOp

%type <AbsBasilIR.program> program
%type <AbsBasilIR.declaration list> declaration_list
%type <AbsBasilIR.bIdent list> bIdent_list
%type <AbsBasilIR.declaration> declaration
%type <AbsBasilIR.mExpr> mExpr
%type <AbsBasilIR.intType> intType
%type <AbsBasilIR.boolType> boolType
%type <AbsBasilIR.mapType> mapType
%type <AbsBasilIR.bVType> bVType
%type <AbsBasilIR.typeT> typeT
%type <AbsBasilIR.expr list> expr_list
%type <AbsBasilIR.intLit> intLit
%type <AbsBasilIR.addrAttr> addrAttr
%type <AbsBasilIR.endian> endian
%type <AbsBasilIR.statement list> statement_list
%type <AbsBasilIR.statement> statement
%type <AbsBasilIR.assign> assign
%type <AbsBasilIR.jump> jump
%type <AbsBasilIR.lVar> lVar
%type <AbsBasilIR.bVLVar> bVLVar
%type <AbsBasilIR.intLVar> intLVar
%type <AbsBasilIR.boolLVar> boolLVar
%type <AbsBasilIR.lVar list> lVar_list
%type <AbsBasilIR.block list> block_list
%type <AbsBasilIR.block> block
%type <AbsBasilIR.pEntry> pEntry
%type <AbsBasilIR.pExit> pExit
%type <AbsBasilIR.pAddress> pAddress
%type <AbsBasilIR.internalBlocks> internalBlocks
%type <AbsBasilIR.procDef> procDef
%type <AbsBasilIR.params> params
%type <AbsBasilIR.params list> params_list
%type <AbsBasilIR.expr> expr
%type <AbsBasilIR.bVExpr> bVExpr
%type <AbsBasilIR.intExpr> intExpr
%type <AbsBasilIR.logExpr> logExpr
%type <AbsBasilIR.intRVar> intRVar
%type <AbsBasilIR.bVRVar> bVRVar
%type <AbsBasilIR.boolRVar> boolRVar
%type <AbsBasilIR.boolLiteral> boolLiteral
%type <AbsBasilIR.bVUnOp> bVUnOp
%type <AbsBasilIR.bVBinOp> bVBinOp
%type <AbsBasilIR.bVLogicalBinOp> bVLogicalBinOp
%type <AbsBasilIR.intBinOp> intBinOp
%type <AbsBasilIR.intLogicalBinOp> intLogicalBinOp
%type <AbsBasilIR.boolBinOp> boolBinOp

%type <int> int
%type <AbsBasilIR.bVTYPE> bVTYPE
%type <AbsBasilIR.bIdent> bIdent
%type <AbsBasilIR.str> str
%type <AbsBasilIR.integerHex> integerHex

%%

pProgram : program TOK_EOF { $1 };

pDeclaration_list : declaration_list TOK_EOF { $1 };

pBIdent_list : bIdent_list TOK_EOF { $1 };

pDeclaration : declaration TOK_EOF { $1 };

pMExpr : mExpr TOK_EOF { $1 };

pIntType : intType TOK_EOF { $1 };

pBoolType : boolType TOK_EOF { $1 };

pMapType : mapType TOK_EOF { $1 };

pBVType : bVType TOK_EOF { $1 };

pTypeT : typeT TOK_EOF { $1 };

pExpr_list : expr_list TOK_EOF { $1 };

pIntLit : intLit TOK_EOF { $1 };

pAddrAttr : addrAttr TOK_EOF { $1 };

pEndian : endian TOK_EOF { $1 };

pStatement_list : statement_list TOK_EOF { $1 };

pStatement : statement TOK_EOF { $1 };

pAssign : assign TOK_EOF { $1 };

pJump : jump TOK_EOF { $1 };

pLVar : lVar TOK_EOF { $1 };

pBVLVar : bVLVar TOK_EOF { $1 };

pIntLVar : intLVar TOK_EOF { $1 };

pBoolLVar : boolLVar TOK_EOF { $1 };

pLVar_list : lVar_list TOK_EOF { $1 };

pBlock_list : block_list TOK_EOF { $1 };

pBlock : block TOK_EOF { $1 };

pPEntry : pEntry TOK_EOF { $1 };

pPExit : pExit TOK_EOF { $1 };

pPAddress : pAddress TOK_EOF { $1 };

pInternalBlocks : internalBlocks TOK_EOF { $1 };

pProcDef : procDef TOK_EOF { $1 };

pParams : params TOK_EOF { $1 };

pParams_list : params_list TOK_EOF { $1 };

pExpr : expr TOK_EOF { $1 };

pBVExpr : bVExpr TOK_EOF { $1 };

pIntExpr : intExpr TOK_EOF { $1 };

pLogExpr : logExpr TOK_EOF { $1 };

pIntRVar : intRVar TOK_EOF { $1 };

pBVRVar : bVRVar TOK_EOF { $1 };

pBoolRVar : boolRVar TOK_EOF { $1 };

pBoolLiteral : boolLiteral TOK_EOF { $1 };

pBVUnOp : bVUnOp TOK_EOF { $1 };

pBVBinOp : bVBinOp TOK_EOF { $1 };

pBVLogicalBinOp : bVLogicalBinOp TOK_EOF { $1 };

pIntBinOp : intBinOp TOK_EOF { $1 };

pIntLogicalBinOp : intLogicalBinOp TOK_EOF { $1 };

pBoolBinOp : boolBinOp TOK_EOF { $1 };

program : declaration_list { Prog $1 }
  ;

declaration_list : /* empty */ { []  }
  | declaration { (fun x -> [x]) $1 }
  | declaration SYMB1 declaration_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

bIdent_list : /* empty */ { []  }
  | bIdent { (fun x -> [x]) $1 }
  | bIdent SYMB2 bIdent_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

declaration : KW_let bIdent SYMB3 mExpr { LetDecl ($2, $4) }
  | KW_memory bIdent SYMB4 typeT { MemDecl ($2, $4) }
  | KW_var bIdent SYMB4 typeT { VarDecl ($2, $4) }
  | KW_proc bIdent SYMB10 params_list SYMB11 SYMB12 SYMB10 params_list SYMB11 procDef { Procedure ($2, $4, $8, $10) }
  ;

mExpr : bIdent { MSym $1 }
  | block { BlockM $1 }
  ;

intType : KW_int { IntT  }
  ;

boolType : KW_bool { BoolT  }
  ;

mapType : KW_map typeT SYMB5 typeT SYMB6 { MapT ($2, $4) }
  ;

bVType : bVTYPE { ShortBVT $1 }
  | KW_bv intLit { BitvectorType $2 }
  ;

typeT : intType { TypeIntType $1 }
  | boolType { TypeBoolType $1 }
  | mapType { TypeMapType $1 }
  | bVType { TypeBVType $1 }
  ;

expr_list : /* empty */ { []  }
  | expr { (fun x -> [x]) $1 }
  | expr SYMB2 expr_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

intLit : integerHex { HexInt $1 }
  | int { DecInt $1 }
  ;

addrAttr : SYMB7 KW_address SYMB3 intLit SYMB8 { AddrAttrSome $4 }
  | /* empty */ { AddrAttrNone  }
  | SYMB7 SYMB8 { AddrAttrEmpty  }
  ;

endian : KW_le { LittleEndian  }
  | KW_be { BigEndian  }
  ;

statement_list : /* empty */ { []  }
  | statement SYMB1 statement_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

statement : assign { AssignStmt $1 }
  | bVLVar SYMB9 KW_load endian bIdent bVExpr intLit { SLoad ($1, $4, $5, $6, $7) }
  | KW_store endian bIdent expr bVExpr intLit { SStore ($2, $3, $4, $5, $6) }
  | KW_call bIdent SYMB10 expr_list SYMB11 { DirectCall ($2, $4) }
  | KW_var SYMB10 lVar_list SYMB11 SYMB9 KW_call bIdent SYMB10 expr_list SYMB11 { DirectCallReturnLocal ($3, $7, $9) }
  | SYMB10 lVar_list SYMB11 SYMB9 KW_call bIdent SYMB10 expr_list SYMB11 { DirectCallReturn ($2, $6, $8) }
  | KW_indirect KW_call expr { IndirectCall $3 }
  | KW_assume expr { Assume $2 }
  | KW_assert expr { Assert $2 }
  ;

assign : intLVar SYMB9 intExpr { IntAssign ($1, $3) }
  | bVLVar SYMB9 bVExpr { BVAssign ($1, $3) }
  | boolLVar SYMB9 logExpr { BoolAssign ($1, $3) }
  ;

jump : KW_goto SYMB10 bIdent_list SYMB11 { GoTo $3 }
  | KW_unreachable { Unreachable  }
  | KW_return SYMB10 expr_list SYMB11 { Return $3 }
  ;

lVar : intLVar { LVarIntLVar $1 }
  | bVLVar { LVarBVLVar $1 }
  | boolLVar { LVarBoolLVar $1 }
  ;

bVLVar : KW_var bIdent SYMB4 bVType { LocalBVLVar ($2, $4) }
  | bIdent SYMB4 bVType { GlobalBVLVar ($1, $3) }
  ;

intLVar : KW_var bIdent SYMB4 intType { LocalIntLVar ($2, $4) }
  | bIdent SYMB4 intType { GlobalIntLVar ($1, $3) }
  ;

boolLVar : KW_var bIdent SYMB4 boolType { LocalBoolLVar ($2, $4) }
  | bIdent SYMB4 boolType { GlobalBoolLVar ($1, $3) }
  ;

lVar_list : /* empty */ { []  }
  | lVar { (fun x -> [x]) $1 }
  | lVar SYMB2 lVar_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

block_list : /* empty */ { []  }
  | block { (fun x -> [x]) $1 }
  | block SYMB1 block_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

block : KW_block bIdent addrAttr SYMB5 statement_list jump SYMB6 { B ($2, $3, $5, $6) }
  ;

pEntry : KW_entry SYMB3 block SYMB1 { EntrySome $3 }
  | /* empty */ { EntryNone  }
  ;

pExit : KW_exit SYMB3 block SYMB1 { ESome $3 }
  | /* empty */ { ENone  }
  ;

pAddress : KW_address SYMB3 intLit SYMB1 { AddrSome $3 }
  | /* empty */ { AddrNone  }
  ;

internalBlocks : KW_blocks SYMB3 SYMB5 block_list SYMB6 SYMB1 { BSome $4 }
  | /* empty */ { BNone  }
  ;

procDef : SYMB7 KW_name SYMB3 str SYMB1 pAddress pEntry pExit internalBlocks SYMB8 { PD ($4, $6, $7, $8, $9) }
  ;

params : bIdent SYMB4 typeT { Param ($1, $3) }
  ;

params_list : /* empty */ { []  }
  | params { (fun x -> [x]) $1 }
  | params SYMB2 params_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

expr : bVExpr { BitvectorExpr $1 }
  | logExpr { LogicalExpr $1 }
  | intExpr { IntegerExpr $1 }
  ;

bVExpr : SYMB10 bVExpr SYMB11 {  $2 }
  | bVBinOp SYMB10 bVExpr SYMB2 bVExpr SYMB11 { BVBinary ($1, $3, $5) }
  | bVUnOp SYMB10 bVExpr SYMB11 { BVUnary ($1, $3) }
  | KW_zero_extend SYMB10 intLit SYMB2 bVExpr SYMB11 { ZeroExtend ($3, $5) }
  | KW_sign_extend SYMB10 intLit SYMB2 bVExpr SYMB11 { SignExtend ($3, $5) }
  | KW_extract SYMB10 intLit SYMB2 intLit SYMB2 bVExpr SYMB11 { Extract ($3, $5, $7) }
  | KW_bvconcat SYMB10 bVExpr SYMB2 bVExpr SYMB11 { Concat ($3, $5) }
  | intLit SYMB4 bVType { BVLiteral ($1, $3) }
  | bVRVar { RBVVar $1 }
  ;

intExpr : SYMB10 intExpr SYMB11 {  $2 }
  | intLit { IntLiteral $1 }
  | intRVar { RIntVar $1 }
  | intBinOp SYMB10 intExpr SYMB2 intExpr SYMB11 { IntBinary ($1, $3, $5) }
  | KW_intneg SYMB10 intExpr SYMB11 { IntNeg $3 }
  ;

logExpr : SYMB10 logExpr SYMB11 {  $2 }
  | bVLogicalBinOp SYMB10 bVExpr SYMB2 bVExpr SYMB11 { BVLogBinary ($1, $3, $5) }
  | boolRVar { RLogVar $1 }
  | boolLiteral { BoolLit $1 }
  | intLogicalBinOp SYMB10 intExpr SYMB2 intExpr SYMB11 { IntLogBinary ($1, $3, $5) }
  | boolBinOp SYMB10 logExpr SYMB2 logExpr SYMB11 { BoolLogBinOp ($1, $3, $5) }
  | KW_boolnot SYMB10 logExpr SYMB11 { BoolNot $3 }
  ;

intRVar : bIdent SYMB4 intType { IRV ($1, $3) }
  ;

bVRVar : bIdent SYMB4 bVType { BVRV ($1, $3) }
  ;

boolRVar : bIdent SYMB4 boolType { BRV ($1, $3) }
  ;

boolLiteral : KW_true { BoolLiteral_true  }
  | KW_false { BoolLiteral_false  }
  ;

bVUnOp : KW_bvnot { BVUnOp_bvnot  }
  | KW_bvneg { BVUnOp_bvneg  }
  ;

bVBinOp : KW_bvand { BVBinOp_bvand  }
  | KW_bvor { BVBinOp_bvor  }
  | KW_bvadd { BVBinOp_bvadd  }
  | KW_bvmul { BVBinOp_bvmul  }
  | KW_bvudiv { BVBinOp_bvudiv  }
  | KW_bvurem { BVBinOp_bvurem  }
  | KW_bvshl { BVBinOp_bvshl  }
  | KW_bvlshr { BVBinOp_bvlshr  }
  | KW_bvnand { BVBinOp_bvnand  }
  | KW_bvnor { BVBinOp_bvnor  }
  | KW_bvxor { BVBinOp_bvxor  }
  | KW_bvxnor { BVBinOp_bvxnor  }
  | KW_bvcomp { BVBinOp_bvcomp  }
  | KW_bvsub { BVBinOp_bvsub  }
  | KW_bvsdiv { BVBinOp_bvsdiv  }
  | KW_bvsrem { BVBinOp_bvsrem  }
  | KW_bvsmod { BVBinOp_bvsmod  }
  | KW_bvashr { BVBinOp_bvashr  }
  ;

bVLogicalBinOp : KW_bvule { BVLogicalBinOp_bvule  }
  | KW_bvugt { BVLogicalBinOp_bvugt  }
  | KW_bvuge { BVLogicalBinOp_bvuge  }
  | KW_bvslt { BVLogicalBinOp_bvslt  }
  | KW_bvsle { BVLogicalBinOp_bvsle  }
  | KW_bvsgt { BVLogicalBinOp_bvsgt  }
  | KW_bvsge { BVLogicalBinOp_bvsge  }
  | KW_bveq { BVLogicalBinOp_bveq  }
  | KW_bvneq { BVLogicalBinOp_bvneq  }
  | KW_bvult { BVLogicalBinOp_bvult  }
  ;

intBinOp : KW_intadd { IntBinOp_intadd  }
  | KW_intmul { IntBinOp_intmul  }
  | KW_intsub { IntBinOp_intsub  }
  | KW_intdiv { IntBinOp_intdiv  }
  | KW_intmod { IntBinOp_intmod  }
  ;

intLogicalBinOp : KW_inteq { IntLogicalBinOp_inteq  }
  | KW_intneq { IntLogicalBinOp_intneq  }
  | KW_intlt { IntLogicalBinOp_intlt  }
  | KW_intle { IntLogicalBinOp_intle  }
  | KW_intgt { IntLogicalBinOp_intgt  }
  | KW_intge { IntLogicalBinOp_intge  }
  ;

boolBinOp : KW_booleq { BoolBinOp_booleq  }
  | KW_boolneq { BoolBinOp_boolneq  }
  | KW_booland { BoolBinOp_booland  }
  | KW_boolor { BoolBinOp_boolor  }
  | KW_boolimplies { BoolBinOp_boolimplies  }
  | KW_boolequiv { BoolBinOp_boolequiv  }
  ;

int :  TOK_Integer  { $1 };
bVTYPE : TOK_BVTYPE { BVTYPE ($1)};
bIdent : TOK_BIdent { BIdent ($1)};
str : TOK_Str { Str ($1)};
integerHex : TOK_IntegerHex { IntegerHex ($1)};


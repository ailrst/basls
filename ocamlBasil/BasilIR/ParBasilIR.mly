/* File generated by the BNF Converter (bnfc 2.9.5). */

/* Parser definition for use with menhir */

%{
open AbsBasilIR
open Lexing
%}

%token KW_let KW_memory KW_var KW_int KW_bool KW_map KW_address KW_le KW_be KW_load KW_store KW_call KW_indirect KW_assume KW_assert KW_goto KW_unreachable KW_return KW_block KW_entry_block KW_blocks KW_name KW_proc KW_boolnot KW_intneg KW_zero_extend KW_sign_extend KW_extract KW_bvconcat KW_true KW_false KW_bvnot KW_bvneg KW_bvand KW_bvor KW_bvadd KW_bvmul KW_bvudiv KW_bvurem KW_bvshl KW_bvlshr KW_bvult KW_bvnand KW_bvnor KW_bvxor KW_bvxnor KW_bvcomp KW_bvsub KW_bvsdiv KW_bvsrem KW_bvsmod KW_bvashr KW_bvule KW_bvugt KW_bvuge KW_bvslt KW_bvsle KW_bvsgt KW_bvsge KW_bveq KW_bvneq KW_intadd KW_intmul KW_intsub KW_intdiv KW_intmod KW_inteq KW_intneq KW_intlt KW_intle KW_intgt KW_intge KW_booleq KW_boolneq KW_booland KW_boolor KW_boolimplies KW_boolequiv

%token SYMB1 /* ; */
%token SYMB2 /* , */
%token SYMB3 /* = */
%token SYMB4 /* : */
%token SYMB5 /* := */
%token SYMB6 /* ( */
%token SYMB7 /* ) */
%token SYMB8 /* -> */

%token TOK_EOF
%token <string> TOK_Ident
%token <char>   TOK_Char
%token <float>  TOK_Double
%token <int>    TOK_Integer
%token <string> TOK_String
%token <string>               TOK_BVTYPE
%token <(int * int) * string> TOK_BIdent
%token <(int * int) * string> TOK_BeginList
%token <(int * int) * string> TOK_EndList
%token <(int * int) * string> TOK_BeginRec
%token <(int * int) * string> TOK_EndRec
%token <string>               TOK_Str
%token <string>               TOK_IntegerHex
%token <string>               TOK_BitvectorHex

%start pProgram pDeclaration_list pBIdent_list pDeclaration pMExpr pIntType pBoolType pMapType pBVType pTypeT pExpr_list pIntVal pAddrAttr pEndian pStatement_list pStatement pCallLVars pJump pLVar pLVar_list pBlock_list pBlock pPEntry pPAddress pInternalBlocks pProcDef pParams pParams_list pExpr pBinOp pUnOp pBVUnOp pBVBinOp pBVLogicalBinOp pIntBinOp pIntLogicalBinOp pBoolBinOp
%type <AbsBasilIR.program> pProgram
%type <AbsBasilIR.declaration list> pDeclaration_list
%type <AbsBasilIR.bIdent list> pBIdent_list
%type <AbsBasilIR.declaration> pDeclaration
%type <AbsBasilIR.mExpr> pMExpr
%type <AbsBasilIR.intType> pIntType
%type <AbsBasilIR.boolType> pBoolType
%type <AbsBasilIR.mapType> pMapType
%type <AbsBasilIR.bVType> pBVType
%type <AbsBasilIR.typeT> pTypeT
%type <AbsBasilIR.expr list> pExpr_list
%type <AbsBasilIR.intVal> pIntVal
%type <AbsBasilIR.addrAttr> pAddrAttr
%type <AbsBasilIR.endian> pEndian
%type <AbsBasilIR.statement list> pStatement_list
%type <AbsBasilIR.statement> pStatement
%type <AbsBasilIR.callLVars> pCallLVars
%type <AbsBasilIR.jump> pJump
%type <AbsBasilIR.lVar> pLVar
%type <AbsBasilIR.lVar list> pLVar_list
%type <AbsBasilIR.block list> pBlock_list
%type <AbsBasilIR.block> pBlock
%type <AbsBasilIR.pEntry> pPEntry
%type <AbsBasilIR.pAddress> pPAddress
%type <AbsBasilIR.internalBlocks> pInternalBlocks
%type <AbsBasilIR.procDef> pProcDef
%type <AbsBasilIR.params> pParams
%type <AbsBasilIR.params list> pParams_list
%type <AbsBasilIR.expr> pExpr
%type <AbsBasilIR.binOp> pBinOp
%type <AbsBasilIR.unOp> pUnOp
%type <AbsBasilIR.bVUnOp> pBVUnOp
%type <AbsBasilIR.bVBinOp> pBVBinOp
%type <AbsBasilIR.bVLogicalBinOp> pBVLogicalBinOp
%type <AbsBasilIR.intBinOp> pIntBinOp
%type <AbsBasilIR.intLogicalBinOp> pIntLogicalBinOp
%type <AbsBasilIR.boolBinOp> pBoolBinOp

%type <AbsBasilIR.program> program
%type <AbsBasilIR.declaration list> declaration_list
%type <AbsBasilIR.bIdent list> bIdent_list
%type <AbsBasilIR.declaration> declaration
%type <AbsBasilIR.mExpr> mExpr
%type <AbsBasilIR.intType> intType
%type <AbsBasilIR.boolType> boolType
%type <AbsBasilIR.mapType> mapType
%type <AbsBasilIR.bVType> bVType
%type <AbsBasilIR.typeT> typeT
%type <AbsBasilIR.expr list> expr_list
%type <AbsBasilIR.intVal> intVal
%type <AbsBasilIR.addrAttr> addrAttr
%type <AbsBasilIR.endian> endian
%type <AbsBasilIR.statement list> statement_list
%type <AbsBasilIR.statement> statement
%type <AbsBasilIR.callLVars> callLVars
%type <AbsBasilIR.jump> jump
%type <AbsBasilIR.lVar> lVar
%type <AbsBasilIR.lVar list> lVar_list
%type <AbsBasilIR.block list> block_list
%type <AbsBasilIR.block> block
%type <AbsBasilIR.pEntry> pEntry
%type <AbsBasilIR.pAddress> pAddress
%type <AbsBasilIR.internalBlocks> internalBlocks
%type <AbsBasilIR.procDef> procDef
%type <AbsBasilIR.params> params
%type <AbsBasilIR.params list> params_list
%type <AbsBasilIR.expr> expr
%type <AbsBasilIR.binOp> binOp
%type <AbsBasilIR.unOp> unOp
%type <AbsBasilIR.bVUnOp> bVUnOp
%type <AbsBasilIR.bVBinOp> bVBinOp
%type <AbsBasilIR.bVLogicalBinOp> bVLogicalBinOp
%type <AbsBasilIR.intBinOp> intBinOp
%type <AbsBasilIR.intLogicalBinOp> intLogicalBinOp
%type <AbsBasilIR.boolBinOp> boolBinOp

%type <int> int
%type <AbsBasilIR.bVTYPE> bVTYPE
%type <AbsBasilIR.bIdent> bIdent
%type <AbsBasilIR.beginList> beginList
%type <AbsBasilIR.endList> endList
%type <AbsBasilIR.beginRec> beginRec
%type <AbsBasilIR.endRec> endRec
%type <AbsBasilIR.str> str
%type <AbsBasilIR.integerHex> integerHex
%type <AbsBasilIR.bitvectorHex> bitvectorHex

%%

pProgram : program TOK_EOF { $1 };

pDeclaration_list : declaration_list TOK_EOF { $1 };

pBIdent_list : bIdent_list TOK_EOF { $1 };

pDeclaration : declaration TOK_EOF { $1 };

pMExpr : mExpr TOK_EOF { $1 };

pIntType : intType TOK_EOF { $1 };

pBoolType : boolType TOK_EOF { $1 };

pMapType : mapType TOK_EOF { $1 };

pBVType : bVType TOK_EOF { $1 };

pTypeT : typeT TOK_EOF { $1 };

pExpr_list : expr_list TOK_EOF { $1 };

pIntVal : intVal TOK_EOF { $1 };

pAddrAttr : addrAttr TOK_EOF { $1 };

pEndian : endian TOK_EOF { $1 };

pStatement_list : statement_list TOK_EOF { $1 };

pStatement : statement TOK_EOF { $1 };

pCallLVars : callLVars TOK_EOF { $1 };

pJump : jump TOK_EOF { $1 };

pLVar : lVar TOK_EOF { $1 };

pLVar_list : lVar_list TOK_EOF { $1 };

pBlock_list : block_list TOK_EOF { $1 };

pBlock : block TOK_EOF { $1 };

pPEntry : pEntry TOK_EOF { $1 };

pPAddress : pAddress TOK_EOF { $1 };

pInternalBlocks : internalBlocks TOK_EOF { $1 };

pProcDef : procDef TOK_EOF { $1 };

pParams : params TOK_EOF { $1 };

pParams_list : params_list TOK_EOF { $1 };

pExpr : expr TOK_EOF { $1 };

pBinOp : binOp TOK_EOF { $1 };

pUnOp : unOp TOK_EOF { $1 };

pBVUnOp : bVUnOp TOK_EOF { $1 };

pBVBinOp : bVBinOp TOK_EOF { $1 };

pBVLogicalBinOp : bVLogicalBinOp TOK_EOF { $1 };

pIntBinOp : intBinOp TOK_EOF { $1 };

pIntLogicalBinOp : intLogicalBinOp TOK_EOF { $1 };

pBoolBinOp : boolBinOp TOK_EOF { $1 };

program : declaration_list { Prog $1 }
  ;

declaration_list : /* empty */ { []  }
  | declaration { (fun x -> [x]) $1 }
  | declaration SYMB1 declaration_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

bIdent_list : /* empty */ { []  }
  | bIdent { (fun x -> [x]) $1 }
  | bIdent SYMB2 bIdent_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

declaration : KW_let bIdent SYMB3 mExpr { LetDecl ($2, $4) }
  | KW_memory bIdent SYMB4 typeT { MemDecl ($2, $4) }
  | KW_var bIdent SYMB4 typeT { VarDecl ($2, $4) }
  | KW_proc bIdent SYMB6 params_list SYMB7 SYMB8 SYMB6 params_list SYMB7 procDef { Procedure ($2, $4, $8, $10) }
  ;

mExpr : bIdent { MSym $1 }
  | block { BlockM $1 }
  ;

intType : KW_int { IntT  }
  ;

boolType : KW_bool { BoolT  }
  ;

mapType : KW_map typeT beginList typeT endList { MapT ($2, $3, $4, $5) }
  ;

bVType : bVTYPE { BVT $1 }
  ;

typeT : intType { TypeIntType $1 }
  | boolType { TypeBoolType $1 }
  | mapType { TypeMapType $1 }
  | bVType { TypeBVType $1 }
  ;

expr_list : /* empty */ { []  }
  | expr { (fun x -> [x]) $1 }
  | expr SYMB2 expr_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

intVal : integerHex { HexInt $1 }
  | int { DecInt $1 }
  ;

addrAttr : beginRec KW_address SYMB3 intVal endRec { AddrAttrSome ($1, $4, $5) }
  | /* empty */ { AddrAttrNone  }
  | beginRec endRec { AddrAttrEmpty ($1, $2) }
  ;

endian : KW_le { LittleEndian  }
  | KW_be { BigEndian  }
  ;

statement_list : /* empty */ { []  }
  | statement SYMB1 statement_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

statement : lVar SYMB5 expr { Assign ($1, $3) }
  | lVar SYMB5 KW_load endian bIdent expr intVal { SLoad ($1, $4, $5, $6, $7) }
  | KW_store endian bIdent expr expr intVal { SStore ($2, $3, $4, $5, $6) }
  | callLVars KW_call bIdent SYMB6 expr_list SYMB7 { DirectCall ($1, $3, $5) }
  | KW_indirect KW_call expr { IndirectCall $3 }
  | KW_assume expr { Assume $2 }
  | KW_assert expr { Assert $2 }
  ;

callLVars : /* empty */ { NoOutParams  }
  | KW_var SYMB6 lVar_list SYMB7 SYMB5 { LocalVars $3 }
  | SYMB6 lVar_list SYMB7 SYMB5 { ListOutParams $2 }
  ;

jump : KW_goto SYMB6 bIdent_list SYMB7 { GoTo $3 }
  | KW_unreachable { Unreachable  }
  | KW_return SYMB6 expr_list SYMB7 { Return $3 }
  ;

lVar : KW_var bIdent SYMB4 typeT { LVarDef ($2, $4) }
  | bIdent SYMB4 typeT { GlobalLVar ($1, $3) }
  ;

lVar_list : lVar { (fun x -> [x]) $1 }
  | lVar SYMB2 lVar_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

block_list : /* empty */ { []  }
  | block { (fun x -> [x]) $1 }
  | block SYMB1 block_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

block : KW_block bIdent addrAttr beginList statement_list jump endList { B ($2, $3, $4, $5, $6, $7) }
  ;

pEntry : KW_entry_block SYMB3 str SYMB1 { EntrySome $3 }
  | /* empty */ { EntryNone  }
  ;

pAddress : KW_address SYMB3 intVal SYMB1 { AddrSome $3 }
  | /* empty */ { AddrNone  }
  ;

internalBlocks : KW_blocks SYMB3 beginList block_list endList SYMB1 { BSome ($3, $4, $5) }
  | /* empty */ { BNone  }
  ;

procDef : beginRec KW_name SYMB3 str SYMB1 pAddress pEntry internalBlocks endRec { PD ($1, $4, $6, $7, $8, $9) }
  ;

params : bIdent SYMB4 typeT { Param ($1, $3) }
  ;

params_list : /* empty */ { []  }
  | params { (fun x -> [x]) $1 }
  | params SYMB2 params_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

expr : SYMB6 expr SYMB7 {  $2 }
  | bIdent SYMB4 typeT { RVar ($1, $3) }
  | binOp SYMB6 expr SYMB2 expr SYMB7 { BinaryExpr ($1, $3, $5) }
  | unOp SYMB6 expr SYMB7 { UnaryExpr ($1, $3) }
  | KW_zero_extend SYMB6 intVal SYMB2 expr SYMB7 { ZeroExtend ($3, $5) }
  | KW_sign_extend SYMB6 intVal SYMB2 expr SYMB7 { SignExtend ($3, $5) }
  | KW_extract SYMB6 intVal SYMB2 intVal SYMB2 expr SYMB7 { Extract ($3, $5, $7) }
  | KW_bvconcat SYMB6 expr SYMB2 expr SYMB7 { Concat ($3, $5) }
  | intVal SYMB4 bVType { BVLiteral ($1, $3) }
  | intVal { IntLiteral $1 }
  | KW_true { TrueLiteral  }
  | KW_false { FalseLiteral  }
  ;

binOp : bVBinOp { BinOpBVBinOp $1 }
  | bVLogicalBinOp { BinOpBVLogicalBinOp $1 }
  | boolBinOp { BinOpBoolBinOp $1 }
  | intLogicalBinOp { BinOpIntLogicalBinOp $1 }
  | intBinOp { BinOpIntBinOp $1 }
  ;

unOp : bVUnOp { UnOpBVUnOp $1 }
  | KW_boolnot { UnOp_boolnot  }
  | KW_intneg { UnOp_intneg  }
  ;

bVUnOp : KW_bvnot { BVUnOp_bvnot  }
  | KW_bvneg { BVUnOp_bvneg  }
  ;

bVBinOp : KW_bvand { BVBinOp_bvand  }
  | KW_bvor { BVBinOp_bvor  }
  | KW_bvadd { BVBinOp_bvadd  }
  | KW_bvmul { BVBinOp_bvmul  }
  | KW_bvudiv { BVBinOp_bvudiv  }
  | KW_bvurem { BVBinOp_bvurem  }
  | KW_bvshl { BVBinOp_bvshl  }
  | KW_bvlshr { BVBinOp_bvlshr  }
  | KW_bvult { BVBinOp_bvult  }
  | KW_bvnand { BVBinOp_bvnand  }
  | KW_bvnor { BVBinOp_bvnor  }
  | KW_bvxor { BVBinOp_bvxor  }
  | KW_bvxnor { BVBinOp_bvxnor  }
  | KW_bvcomp { BVBinOp_bvcomp  }
  | KW_bvsub { BVBinOp_bvsub  }
  | KW_bvsdiv { BVBinOp_bvsdiv  }
  | KW_bvsrem { BVBinOp_bvsrem  }
  | KW_bvsmod { BVBinOp_bvsmod  }
  | KW_bvashr { BVBinOp_bvashr  }
  ;

bVLogicalBinOp : KW_bvule { BVLogicalBinOp_bvule  }
  | KW_bvugt { BVLogicalBinOp_bvugt  }
  | KW_bvuge { BVLogicalBinOp_bvuge  }
  | KW_bvslt { BVLogicalBinOp_bvslt  }
  | KW_bvsle { BVLogicalBinOp_bvsle  }
  | KW_bvsgt { BVLogicalBinOp_bvsgt  }
  | KW_bvsge { BVLogicalBinOp_bvsge  }
  | KW_bveq { BVLogicalBinOp_bveq  }
  | KW_bvneq { BVLogicalBinOp_bvneq  }
  ;

intBinOp : KW_intadd { IntBinOp_intadd  }
  | KW_intmul { IntBinOp_intmul  }
  | KW_intsub { IntBinOp_intsub  }
  | KW_intdiv { IntBinOp_intdiv  }
  | KW_intmod { IntBinOp_intmod  }
  ;

intLogicalBinOp : KW_inteq { IntLogicalBinOp_inteq  }
  | KW_intneq { IntLogicalBinOp_intneq  }
  | KW_intlt { IntLogicalBinOp_intlt  }
  | KW_intle { IntLogicalBinOp_intle  }
  | KW_intgt { IntLogicalBinOp_intgt  }
  | KW_intge { IntLogicalBinOp_intge  }
  ;

boolBinOp : KW_booleq { BoolBinOp_booleq  }
  | KW_boolneq { BoolBinOp_boolneq  }
  | KW_booland { BoolBinOp_booland  }
  | KW_boolor { BoolBinOp_boolor  }
  | KW_boolimplies { BoolBinOp_boolimplies  }
  | KW_boolequiv { BoolBinOp_boolequiv  }
  ;

int :  TOK_Integer  { $1 };
bVTYPE : TOK_BVTYPE { BVTYPE ($1)};
bIdent : TOK_BIdent { BIdent ($1)};
beginList : TOK_BeginList { BeginList ($1)};
endList : TOK_EndList { EndList ($1)};
beginRec : TOK_BeginRec { BeginRec ($1)};
endRec : TOK_EndRec { EndRec ($1)};
str : TOK_Str { Str ($1)};
integerHex : TOK_IntegerHex { IntegerHex ($1)};
bitvectorHex : TOK_BitvectorHex { BitvectorHex ($1)};


/* File generated by the BNF Converter (bnfc 2.9.5). */

/* Parser definition for use with menhir */

%{
open AbsBasilIR
open Lexing
%}

%token KW_axiom KW_memory KW_var KW_prog KW_int KW_bool KW_map KW_le KW_be KW_load KW_store KW_call KW_indirect KW_assume KW_guard KW_assert KW_goto KW_unreachable KW_return KW_block KW_proc KW_true KW_false KW_boolnot KW_intneg KW_booltobv1 KW_zero_extend KW_sign_extend KW_extract KW_bvconcat KW_eq KW_neq KW_bvnot KW_bvneg KW_bvand KW_bvor KW_bvadd KW_bvmul KW_bvudiv KW_bvurem KW_bvshl KW_bvlshr KW_bvnand KW_bvnor KW_bvxor KW_bvxnor KW_bvcomp KW_bvsub KW_bvsdiv KW_bvsrem KW_bvsmod KW_bvashr KW_bvule KW_bvugt KW_bvuge KW_bvult KW_bvslt KW_bvsle KW_bvsgt KW_bvsge KW_intadd KW_intmul KW_intsub KW_intdiv KW_intmod KW_intlt KW_intle KW_intgt KW_intge KW_booland KW_boolor KW_boolimplies KW_require KW_requires KW_ensure KW_ensures KW_invariant KW_rely KW_guarantee

%token SYMB1 /* ; */
%token SYMB2 /* , */
%token SYMB3 /* : */
%token SYMB4 /* := */
%token SYMB5 /* ( */
%token SYMB6 /* ) */
%token SYMB7 /* = */
%token SYMB8 /* -> */

%token TOK_EOF
%token <string> TOK_Ident
%token <char>   TOK_Char
%token <float>  TOK_Double
%token <int>    TOK_Integer
%token <string> TOK_String
%token <string>               TOK_BVTYPE
%token <(int * int) * string> TOK_BIdent
%token <(int * int) * string> TOK_LocalIdent
%token <(int * int) * string> TOK_GlobalIdent
%token <(int * int) * string> TOK_BlockIdent
%token <(int * int) * string> TOK_ProcIdent
%token <(int * int) * string> TOK_BeginList
%token <(int * int) * string> TOK_EndList
%token <(int * int) * string> TOK_BeginRec
%token <(int * int) * string> TOK_EndRec
%token <string>               TOK_Str
%token <string>               TOK_IntegerHex
%token <string>               TOK_BitvectorHex

%start pProgram pDeclaration_list pBlockIdent_list pGobbleScolon pDeclaration pIntType pBoolType pMapType pBVType pTypeT pExpr_list pIntVal pBVVal pEndian pStatement_list pAssignment pStatement pAssignment_list pLocalVar pGlobalVar pLocalVar_list pCallLVars pJump pLVar pLVar_list pBlock_list pBlock pAttributeItem pAttributeItem_list pAttrDefList pParams pParams_list pProcSig pProcDef pExpr pBinOp pUnOp pEqOp pBVUnOp pBVBinOp pBVLogicalBinOp pIntBinOp pIntLogicalBinOp pBoolBinOp pREQUIRE pENSURE pFunSpecDecl pProgSpecDecl pFunSpecDecl_list pProgSpecDecl_list
%type <AbsBasilIR.program> pProgram
%type <AbsBasilIR.declaration list> pDeclaration_list
%type <AbsBasilIR.blockIdent list> pBlockIdent_list
%type <AbsBasilIR.gobbleScolon> pGobbleScolon
%type <AbsBasilIR.declaration> pDeclaration
%type <AbsBasilIR.intType> pIntType
%type <AbsBasilIR.boolType> pBoolType
%type <AbsBasilIR.mapType> pMapType
%type <AbsBasilIR.bVType> pBVType
%type <AbsBasilIR.typeT> pTypeT
%type <AbsBasilIR.expr list> pExpr_list
%type <AbsBasilIR.intVal> pIntVal
%type <AbsBasilIR.bVVal> pBVVal
%type <AbsBasilIR.endian> pEndian
%type <AbsBasilIR.statement list> pStatement_list
%type <AbsBasilIR.assignment> pAssignment
%type <AbsBasilIR.statement> pStatement
%type <AbsBasilIR.assignment list> pAssignment_list
%type <AbsBasilIR.localVar> pLocalVar
%type <AbsBasilIR.globalVar> pGlobalVar
%type <AbsBasilIR.localVar list> pLocalVar_list
%type <AbsBasilIR.callLVars> pCallLVars
%type <AbsBasilIR.jump> pJump
%type <AbsBasilIR.lVar> pLVar
%type <AbsBasilIR.lVar list> pLVar_list
%type <AbsBasilIR.block list> pBlock_list
%type <AbsBasilIR.block> pBlock
%type <AbsBasilIR.attributeItem> pAttributeItem
%type <AbsBasilIR.attributeItem list> pAttributeItem_list
%type <AbsBasilIR.attrDefList> pAttrDefList
%type <AbsBasilIR.params> pParams
%type <AbsBasilIR.params list> pParams_list
%type <AbsBasilIR.procSig> pProcSig
%type <AbsBasilIR.procDef> pProcDef
%type <AbsBasilIR.expr> pExpr
%type <AbsBasilIR.binOp> pBinOp
%type <AbsBasilIR.unOp> pUnOp
%type <AbsBasilIR.eqOp> pEqOp
%type <AbsBasilIR.bVUnOp> pBVUnOp
%type <AbsBasilIR.bVBinOp> pBVBinOp
%type <AbsBasilIR.bVLogicalBinOp> pBVLogicalBinOp
%type <AbsBasilIR.intBinOp> pIntBinOp
%type <AbsBasilIR.intLogicalBinOp> pIntLogicalBinOp
%type <AbsBasilIR.boolBinOp> pBoolBinOp
%type <AbsBasilIR.rEQUIRE> pREQUIRE
%type <AbsBasilIR.eNSURE> pENSURE
%type <AbsBasilIR.funSpecDecl> pFunSpecDecl
%type <AbsBasilIR.progSpecDecl> pProgSpecDecl
%type <AbsBasilIR.funSpecDecl list> pFunSpecDecl_list
%type <AbsBasilIR.progSpecDecl list> pProgSpecDecl_list

%type <AbsBasilIR.program> program
%type <AbsBasilIR.declaration list> declaration_list
%type <AbsBasilIR.blockIdent list> blockIdent_list
%type <AbsBasilIR.gobbleScolon> gobbleScolon
%type <AbsBasilIR.declaration> declaration
%type <AbsBasilIR.intType> intType
%type <AbsBasilIR.boolType> boolType
%type <AbsBasilIR.mapType> mapType
%type <AbsBasilIR.bVType> bVType
%type <AbsBasilIR.typeT> typeT
%type <AbsBasilIR.expr list> expr_list
%type <AbsBasilIR.intVal> intVal
%type <AbsBasilIR.bVVal> bVVal
%type <AbsBasilIR.endian> endian
%type <AbsBasilIR.statement list> statement_list
%type <AbsBasilIR.assignment> assignment
%type <AbsBasilIR.statement> statement
%type <AbsBasilIR.assignment list> assignment_list
%type <AbsBasilIR.localVar> localVar
%type <AbsBasilIR.globalVar> globalVar
%type <AbsBasilIR.localVar list> localVar_list
%type <AbsBasilIR.callLVars> callLVars
%type <AbsBasilIR.jump> jump
%type <AbsBasilIR.lVar> lVar
%type <AbsBasilIR.lVar list> lVar_list
%type <AbsBasilIR.block list> block_list
%type <AbsBasilIR.block> block
%type <AbsBasilIR.attributeItem> attributeItem
%type <AbsBasilIR.attributeItem list> attributeItem_list
%type <AbsBasilIR.attrDefList> attrDefList
%type <AbsBasilIR.params> params
%type <AbsBasilIR.params list> params_list
%type <AbsBasilIR.procSig> procSig
%type <AbsBasilIR.procDef> procDef
%type <AbsBasilIR.expr> expr
%type <AbsBasilIR.binOp> binOp
%type <AbsBasilIR.unOp> unOp
%type <AbsBasilIR.eqOp> eqOp
%type <AbsBasilIR.bVUnOp> bVUnOp
%type <AbsBasilIR.bVBinOp> bVBinOp
%type <AbsBasilIR.bVLogicalBinOp> bVLogicalBinOp
%type <AbsBasilIR.intBinOp> intBinOp
%type <AbsBasilIR.intLogicalBinOp> intLogicalBinOp
%type <AbsBasilIR.boolBinOp> boolBinOp
%type <AbsBasilIR.rEQUIRE> rEQUIRE
%type <AbsBasilIR.eNSURE> eNSURE
%type <AbsBasilIR.funSpecDecl> funSpecDecl
%type <AbsBasilIR.progSpecDecl> progSpecDecl
%type <AbsBasilIR.funSpecDecl list> funSpecDecl_list
%type <AbsBasilIR.progSpecDecl list> progSpecDecl_list

%type <int> int
%type <AbsBasilIR.bVTYPE> bVTYPE
%type <AbsBasilIR.bIdent> bIdent
%type <AbsBasilIR.localIdent> localIdent
%type <AbsBasilIR.globalIdent> globalIdent
%type <AbsBasilIR.blockIdent> blockIdent
%type <AbsBasilIR.procIdent> procIdent
%type <AbsBasilIR.beginList> beginList
%type <AbsBasilIR.endList> endList
%type <AbsBasilIR.beginRec> beginRec
%type <AbsBasilIR.endRec> endRec
%type <AbsBasilIR.str> str
%type <AbsBasilIR.integerHex> integerHex
%type <AbsBasilIR.bitvectorHex> bitvectorHex

%%

pProgram : program TOK_EOF { $1 };

pDeclaration_list : declaration_list TOK_EOF { $1 };

pBlockIdent_list : blockIdent_list TOK_EOF { $1 };

pGobbleScolon : gobbleScolon TOK_EOF { $1 };

pDeclaration : declaration TOK_EOF { $1 };

pIntType : intType TOK_EOF { $1 };

pBoolType : boolType TOK_EOF { $1 };

pMapType : mapType TOK_EOF { $1 };

pBVType : bVType TOK_EOF { $1 };

pTypeT : typeT TOK_EOF { $1 };

pExpr_list : expr_list TOK_EOF { $1 };

pIntVal : intVal TOK_EOF { $1 };

pBVVal : bVVal TOK_EOF { $1 };

pEndian : endian TOK_EOF { $1 };

pStatement_list : statement_list TOK_EOF { $1 };

pAssignment : assignment TOK_EOF { $1 };

pStatement : statement TOK_EOF { $1 };

pAssignment_list : assignment_list TOK_EOF { $1 };

pLocalVar : localVar TOK_EOF { $1 };

pGlobalVar : globalVar TOK_EOF { $1 };

pLocalVar_list : localVar_list TOK_EOF { $1 };

pCallLVars : callLVars TOK_EOF { $1 };

pJump : jump TOK_EOF { $1 };

pLVar : lVar TOK_EOF { $1 };

pLVar_list : lVar_list TOK_EOF { $1 };

pBlock_list : block_list TOK_EOF { $1 };

pBlock : block TOK_EOF { $1 };

pAttributeItem : attributeItem TOK_EOF { $1 };

pAttributeItem_list : attributeItem_list TOK_EOF { $1 };

pAttrDefList : attrDefList TOK_EOF { $1 };

pParams : params TOK_EOF { $1 };

pParams_list : params_list TOK_EOF { $1 };

pProcSig : procSig TOK_EOF { $1 };

pProcDef : procDef TOK_EOF { $1 };

pExpr : expr TOK_EOF { $1 };

pBinOp : binOp TOK_EOF { $1 };

pUnOp : unOp TOK_EOF { $1 };

pEqOp : eqOp TOK_EOF { $1 };

pBVUnOp : bVUnOp TOK_EOF { $1 };

pBVBinOp : bVBinOp TOK_EOF { $1 };

pBVLogicalBinOp : bVLogicalBinOp TOK_EOF { $1 };

pIntBinOp : intBinOp TOK_EOF { $1 };

pIntLogicalBinOp : intLogicalBinOp TOK_EOF { $1 };

pBoolBinOp : boolBinOp TOK_EOF { $1 };

pREQUIRE : rEQUIRE TOK_EOF { $1 };

pENSURE : eNSURE TOK_EOF { $1 };

pFunSpecDecl : funSpecDecl TOK_EOF { $1 };

pProgSpecDecl : progSpecDecl TOK_EOF { $1 };

pFunSpecDecl_list : funSpecDecl_list TOK_EOF { $1 };

pProgSpecDecl_list : progSpecDecl_list TOK_EOF { $1 };

program : declaration_list { Prog $1 }
  ;

declaration_list : /* empty */ { []  }
  | declaration SYMB1 declaration_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

blockIdent_list : /* empty */ { []  }
  | blockIdent { (fun x -> [x]) $1 }
  | blockIdent SYMB2 blockIdent_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

gobbleScolon : /* empty */ { EmptyScolon  }
  | gobbleScolon SYMB1 { SomeScolon $1 }
  ;

declaration : KW_axiom attrDefList expr { AxiomDecl ($2, $3) }
  | KW_memory globalIdent SYMB3 typeT { MemDecl ($2, $4) }
  | KW_var globalIdent SYMB3 typeT { VarDecl ($2, $4) }
  | KW_prog attrDefList beginList progSpecDecl_list endList { ProgDeclSpec ($2, $3, $4, $5) }
  | KW_prog attrDefList { ProgDecl $2 }
  | procDef { Procedure $1 }
  ;

intType : KW_int { IntT  }
  ;

boolType : KW_bool { BoolT  }
  ;

mapType : KW_map typeT beginList typeT endList { MapT ($2, $3, $4, $5) }
  ;

bVType : bVTYPE { BVT $1 }
  ;

typeT : intType { TypeIntType $1 }
  | boolType { TypeBoolType $1 }
  | mapType { TypeMapType $1 }
  | bVType { TypeBVType $1 }
  ;

expr_list : /* empty */ { []  }
  | expr { (fun x -> [x]) $1 }
  | expr SYMB2 expr_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

intVal : integerHex { HexInt $1 }
  | int { DecInt $1 }
  ;

bVVal : intVal SYMB3 bVType { BV ($1, $3) }
  ;

endian : KW_le { LittleEndian  }
  | KW_be { BigEndian  }
  ;

statement_list : /* empty */ { []  }
  | statement SYMB1 statement_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

assignment : lVar SYMB4 expr { Assignment1 ($1, $3) }
  ;

statement : assignment { Assign $1 }
  | SYMB5 assignment_list SYMB6 { SimulAssign $2 }
  | lVar SYMB4 KW_load endian globalIdent expr intVal { SLoad ($1, $4, $5, $6, $7) }
  | KW_store endian globalIdent expr expr intVal { SStore ($2, $3, $4, $5, $6) }
  | callLVars KW_call procIdent SYMB5 expr_list SYMB6 { DirectCall ($1, $3, $5) }
  | KW_indirect KW_call expr { IndirectCall $3 }
  | KW_assume expr attrDefList { Assume ($2, $3) }
  | KW_guard expr attrDefList { Guard ($2, $3) }
  | KW_assert expr attrDefList { Assert ($2, $3) }
  ;

assignment_list : assignment { (fun x -> [x]) $1 }
  | assignment SYMB2 assignment_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

localVar : localIdent SYMB3 typeT { LocalVar1 ($1, $3) }
  ;

globalVar : globalIdent SYMB3 typeT { GlobalVar1 ($1, $3) }
  ;

localVar_list : localVar { (fun x -> [x]) $1 }
  | localVar SYMB2 localVar_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

callLVars : /* empty */ { NoOutParams  }
  | KW_var SYMB5 localVar_list SYMB6 SYMB4 { LocalVars $3 }
  | SYMB5 lVar_list SYMB6 SYMB4 { ListOutParams $2 }
  ;

jump : KW_goto SYMB5 blockIdent_list SYMB6 { GoTo $3 }
  | KW_unreachable { Unreachable  }
  | KW_return SYMB5 expr_list SYMB6 { Return $3 }
  ;

lVar : KW_var localVar { LVarDef $2 }
  | globalVar { GlobalLVar $1 }
  ;

lVar_list : lVar { (fun x -> [x]) $1 }
  | lVar SYMB2 lVar_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

block_list : /* empty */ { []  }
  | block { (fun x -> [x]) $1 }
  | block SYMB1 block_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

block : KW_block blockIdent attrDefList beginList statement_list jump SYMB1 endList { Block1 ($2, $3, $4, $5, $6, $8) }
  ;

attributeItem : bIdent SYMB7 intVal { IntAttr ($1, $3) }
  | bIdent SYMB7 bVVal { BVAttr ($1, $3) }
  | bIdent SYMB7 expr { ExprAttr ($1, $3) }
  | bIdent SYMB7 str { StringAttr ($1, $3) }
  ;

attributeItem_list : /* empty */ { []  }
  | attributeItem { (fun x -> [x]) $1 }
  | attributeItem SYMB1 attributeItem_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

attrDefList : beginRec attributeItem_list gobbleScolon endRec { AttrDefListSome ($1, $2, $3, $4) }
  | /* empty */ { AttrDefListEmpty  }
  ;

params : localIdent SYMB3 typeT { Param ($1, $3) }
  ;

params_list : /* empty */ { []  }
  | params { (fun x -> [x]) $1 }
  | params SYMB2 params_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

procSig : KW_proc procIdent SYMB5 params_list SYMB6 SYMB8 SYMB5 params_list SYMB6 { ProcedureSig ($2, $4, $8) }
  ;

procDef : procSig attrDefList funSpecDecl_list { ProcedureDecl ($1, $2, $3) }
  | procSig attrDefList funSpecDecl_list beginList block_list endList { ProcedureDef ($1, $2, $3, $4, $5, $6) }
  ;

expr : bVVal { BVLiteral $1 }
  | intVal { IntLiteral $1 }
  | KW_true { TrueLiteral  }
  | KW_false { FalseLiteral  }
  | localVar { LRVar $1 }
  | globalVar { GRVar $1 }
  | globalIdent SYMB5 expr_list SYMB6 { FunctionOp ($1, $3) }
  | binOp SYMB5 expr SYMB2 expr SYMB6 { BinaryExpr ($1, $3, $5) }
  | unOp SYMB5 expr SYMB6 { UnaryExpr ($1, $3) }
  | KW_zero_extend SYMB5 intVal SYMB2 expr SYMB6 { ZeroExtend ($3, $5) }
  | KW_sign_extend SYMB5 intVal SYMB2 expr SYMB6 { SignExtend ($3, $5) }
  | KW_extract SYMB5 intVal SYMB2 intVal SYMB2 expr SYMB6 { Extract ($3, $5, $7) }
  | KW_bvconcat SYMB5 expr SYMB2 expr SYMB6 { Concat ($3, $5) }
  ;

binOp : bVBinOp { BinOpBVBinOp $1 }
  | bVLogicalBinOp { BinOpBVLogicalBinOp $1 }
  | boolBinOp { BinOpBoolBinOp $1 }
  | intLogicalBinOp { BinOpIntLogicalBinOp $1 }
  | intBinOp { BinOpIntBinOp $1 }
  | eqOp { BinOpEqOp $1 }
  ;

unOp : bVUnOp { UnOpBVUnOp $1 }
  | KW_boolnot { UnOp_boolnot  }
  | KW_intneg { UnOp_intneg  }
  | KW_booltobv1 { UnOp_booltobv1  }
  ;

eqOp : KW_eq { EqOp_eq  }
  | KW_neq { EqOp_neq  }
  ;

bVUnOp : KW_bvnot { BVUnOp_bvnot  }
  | KW_bvneg { BVUnOp_bvneg  }
  ;

bVBinOp : KW_bvand { BVBinOp_bvand  }
  | KW_bvor { BVBinOp_bvor  }
  | KW_bvadd { BVBinOp_bvadd  }
  | KW_bvmul { BVBinOp_bvmul  }
  | KW_bvudiv { BVBinOp_bvudiv  }
  | KW_bvurem { BVBinOp_bvurem  }
  | KW_bvshl { BVBinOp_bvshl  }
  | KW_bvlshr { BVBinOp_bvlshr  }
  | KW_bvnand { BVBinOp_bvnand  }
  | KW_bvnor { BVBinOp_bvnor  }
  | KW_bvxor { BVBinOp_bvxor  }
  | KW_bvxnor { BVBinOp_bvxnor  }
  | KW_bvcomp { BVBinOp_bvcomp  }
  | KW_bvsub { BVBinOp_bvsub  }
  | KW_bvsdiv { BVBinOp_bvsdiv  }
  | KW_bvsrem { BVBinOp_bvsrem  }
  | KW_bvsmod { BVBinOp_bvsmod  }
  | KW_bvashr { BVBinOp_bvashr  }
  ;

bVLogicalBinOp : KW_bvule { BVLogicalBinOp_bvule  }
  | KW_bvugt { BVLogicalBinOp_bvugt  }
  | KW_bvuge { BVLogicalBinOp_bvuge  }
  | KW_bvult { BVLogicalBinOp_bvult  }
  | KW_bvslt { BVLogicalBinOp_bvslt  }
  | KW_bvsle { BVLogicalBinOp_bvsle  }
  | KW_bvsgt { BVLogicalBinOp_bvsgt  }
  | KW_bvsge { BVLogicalBinOp_bvsge  }
  ;

intBinOp : KW_intadd { IntBinOp_intadd  }
  | KW_intmul { IntBinOp_intmul  }
  | KW_intsub { IntBinOp_intsub  }
  | KW_intdiv { IntBinOp_intdiv  }
  | KW_intmod { IntBinOp_intmod  }
  ;

intLogicalBinOp : KW_intlt { IntLogicalBinOp_intlt  }
  | KW_intle { IntLogicalBinOp_intle  }
  | KW_intgt { IntLogicalBinOp_intgt  }
  | KW_intge { IntLogicalBinOp_intge  }
  ;

boolBinOp : KW_booland { BoolBinOp_booland  }
  | KW_boolor { BoolBinOp_boolor  }
  | KW_boolimplies { BoolBinOp_boolimplies  }
  ;

rEQUIRE : KW_require { REQUIRE_require  }
  | KW_requires { REQUIRE_requires  }
  ;

eNSURE : KW_ensure { ENSURE_ensure  }
  | KW_ensures { ENSURE_ensures  }
  ;

funSpecDecl : rEQUIRE expr { Require ($1, $2) }
  | eNSURE expr { Ensure ($1, $2) }
  | KW_invariant blockIdent expr { LoopInvariant ($2, $3) }
  ;

progSpecDecl : KW_rely expr { Rely $2 }
  | KW_guarantee expr { Guarantee $2 }
  ;

funSpecDecl_list : /* empty */ { []  }
  | funSpecDecl SYMB1 funSpecDecl_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

progSpecDecl_list : /* empty */ { []  }
  | progSpecDecl SYMB1 progSpecDecl_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

int :  TOK_Integer  { $1 };
bVTYPE : TOK_BVTYPE { BVTYPE ($1)};
bIdent : TOK_BIdent { BIdent ($1)};
localIdent : TOK_LocalIdent { LocalIdent ($1)};
globalIdent : TOK_GlobalIdent { GlobalIdent ($1)};
blockIdent : TOK_BlockIdent { BlockIdent ($1)};
procIdent : TOK_ProcIdent { ProcIdent ($1)};
beginList : TOK_BeginList { BeginList ($1)};
endList : TOK_EndList { EndList ($1)};
beginRec : TOK_BeginRec { BeginRec ($1)};
endRec : TOK_EndRec { EndRec ($1)};
str : TOK_Str { Str ($1)};
integerHex : TOK_IntegerHex { IntegerHex ($1)};
bitvectorHex : TOK_BitvectorHex { BitvectorHex ($1)};


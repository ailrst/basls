(* File generated by the BNF Converter (bnfc 2.9.5). *)

(* show functions *)

(* use string buffers for efficient string concatenations *)
type showable = Buffer.t -> unit

let show (s : showable) : string =
    let init_size = 16 in (* you may want to adjust this *)
    let b = Buffer.create init_size in
    s b;
    Buffer.contents b

let emptyS : showable = fun buf -> ()

let c2s (c:char) : showable = fun buf -> Buffer.add_char buf c
let s2s (s:string) : showable = fun buf -> Buffer.add_string buf s

let ( >> ) (s1 : showable) (s2 : showable) : showable = fun buf -> s1 buf; s2 buf

let showChar (c:char) : showable = fun buf ->
    Buffer.add_string buf ("'" ^ Char.escaped c ^ "'")

let showString (s:string) : showable = fun buf ->
    Buffer.add_string buf ("\"" ^ String.escaped s ^ "\"")

let showList (showFun : 'a -> showable) (xs : 'a list) : showable = fun buf ->
    let rec f ys = match ys with
        [] -> ()
      | [y] -> showFun y buf
      | y::ys -> showFun y buf; Buffer.add_string buf "; "; f ys
    in
        Buffer.add_char buf '[';
        f xs;
        Buffer.add_char buf ']'


let showInt (i:int) : showable = s2s (string_of_int i)
let showFloat (f:float) : showable = s2s (string_of_float f)

let rec showBVTYPE (AbsBasilIR.BVTYPE i) : showable = s2s "BVTYPE " >> showString i
let rec showBIdent (AbsBasilIR.BIdent (_,i)) : showable = s2s "BIdent " >> showString i
let rec showBeginList (AbsBasilIR.BeginList (_,i)) : showable = s2s "BeginList " >> showString i
let rec showEndList (AbsBasilIR.EndList (_,i)) : showable = s2s "EndList " >> showString i
let rec showBeginRec (AbsBasilIR.BeginRec (_,i)) : showable = s2s "BeginRec " >> showString i
let rec showEndRec (AbsBasilIR.EndRec (_,i)) : showable = s2s "EndRec " >> showString i
let rec showStr (AbsBasilIR.Str i) : showable = s2s "Str " >> showString i
let rec showIntegerHex (AbsBasilIR.IntegerHex i) : showable = s2s "IntegerHex " >> showString i
let rec showBitvectorHex (AbsBasilIR.BitvectorHex i) : showable = s2s "BitvectorHex " >> showString i

let rec showProgram (e : AbsBasilIR.program) : showable = match e with
       AbsBasilIR.Prog declarations -> s2s "Prog" >> c2s ' ' >> c2s '(' >> showList showDeclaration declarations >> c2s ')'


and showDeclaration (e : AbsBasilIR.declaration) : showable = match e with
       AbsBasilIR.LetDecl (bident, mexpr) -> s2s "LetDecl" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showMExpr mexpr >> c2s ')'
  |    AbsBasilIR.MemDecl (bident, type') -> s2s "MemDecl" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showTypeT type' >> c2s ')'
  |    AbsBasilIR.VarDecl (bident, type') -> s2s "VarDecl" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showTypeT type' >> c2s ')'
  |    AbsBasilIR.Procedure (bident, paramss0, paramss, procdef) -> s2s "Procedure" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showList showParams paramss0  >> s2s ", " >>  showList showParams paramss  >> s2s ", " >>  showProcDef procdef >> c2s ')'


and showMExpr (e : AbsBasilIR.mExpr) : showable = match e with
       AbsBasilIR.MSym bident -> s2s "MSym" >> c2s ' ' >> c2s '(' >> showBIdent bident >> c2s ')'
  |    AbsBasilIR.BlockM block -> s2s "BlockM" >> c2s ' ' >> c2s '(' >> showBlock block >> c2s ')'


and showIntType (e : AbsBasilIR.intType) : showable = match e with
       AbsBasilIR.IntT  -> s2s "IntT"


and showBoolType (e : AbsBasilIR.boolType) : showable = match e with
       AbsBasilIR.BoolT  -> s2s "BoolT"


and showMapType (e : AbsBasilIR.mapType) : showable = match e with
       AbsBasilIR.MapT (type'0, beginlist, type', endlist) -> s2s "MapT" >> c2s ' ' >> c2s '(' >> showTypeT type'0  >> s2s ", " >>  showBeginList beginlist  >> s2s ", " >>  showTypeT type'  >> s2s ", " >>  showEndList endlist >> c2s ')'


and showBVType (e : AbsBasilIR.bVType) : showable = match e with
       AbsBasilIR.BVT bvtype -> s2s "BVT" >> c2s ' ' >> c2s '(' >> showBVTYPE bvtype >> c2s ')'


and showTypeT (e : AbsBasilIR.typeT) : showable = match e with
       AbsBasilIR.TypeIntType inttype -> s2s "TypeIntType" >> c2s ' ' >> c2s '(' >> showIntType inttype >> c2s ')'
  |    AbsBasilIR.TypeBoolType booltype -> s2s "TypeBoolType" >> c2s ' ' >> c2s '(' >> showBoolType booltype >> c2s ')'
  |    AbsBasilIR.TypeMapType maptype -> s2s "TypeMapType" >> c2s ' ' >> c2s '(' >> showMapType maptype >> c2s ')'
  |    AbsBasilIR.TypeBVType bvtype -> s2s "TypeBVType" >> c2s ' ' >> c2s '(' >> showBVType bvtype >> c2s ')'


and showIntVal (e : AbsBasilIR.intVal) : showable = match e with
       AbsBasilIR.HexInt integerhex -> s2s "HexInt" >> c2s ' ' >> c2s '(' >> showIntegerHex integerhex >> c2s ')'
  |    AbsBasilIR.DecInt integer -> s2s "DecInt" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'


and showAddrAttr (e : AbsBasilIR.addrAttr) : showable = match e with
       AbsBasilIR.AddrAttrSome (beginrec, intval, endrec) -> s2s "AddrAttrSome" >> c2s ' ' >> c2s '(' >> showBeginRec beginrec  >> s2s ", " >>  showIntVal intval  >> s2s ", " >>  showEndRec endrec >> c2s ')'
  |    AbsBasilIR.AddrAttrNone  -> s2s "AddrAttrNone"
  |    AbsBasilIR.AddrAttrEmpty (beginrec, endrec) -> s2s "AddrAttrEmpty" >> c2s ' ' >> c2s '(' >> showBeginRec beginrec  >> s2s ", " >>  showEndRec endrec >> c2s ')'


and showEndian (e : AbsBasilIR.endian) : showable = match e with
       AbsBasilIR.LittleEndian  -> s2s "LittleEndian"
  |    AbsBasilIR.BigEndian  -> s2s "BigEndian"


and showStatement (e : AbsBasilIR.statement) : showable = match e with
       AbsBasilIR.Assign (lvar, expr) -> s2s "Assign" >> c2s ' ' >> c2s '(' >> showLVar lvar  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.SLoad (lvar, endian, bident, expr, intval) -> s2s "SLoad" >> c2s ' ' >> c2s '(' >> showLVar lvar  >> s2s ", " >>  showEndian endian  >> s2s ", " >>  showBIdent bident  >> s2s ", " >>  showExpr expr  >> s2s ", " >>  showIntVal intval >> c2s ')'
  |    AbsBasilIR.SStore (endian, bident, expr0, expr, intval) -> s2s "SStore" >> c2s ' ' >> c2s '(' >> showEndian endian  >> s2s ", " >>  showBIdent bident  >> s2s ", " >>  showExpr expr0  >> s2s ", " >>  showExpr expr  >> s2s ", " >>  showIntVal intval >> c2s ')'
  |    AbsBasilIR.DirectCall (calllvars, bident, exprs) -> s2s "DirectCall" >> c2s ' ' >> c2s '(' >> showCallLVars calllvars  >> s2s ", " >>  showBIdent bident  >> s2s ", " >>  showList showExpr exprs >> c2s ')'
  |    AbsBasilIR.IndirectCall expr -> s2s "IndirectCall" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'
  |    AbsBasilIR.Assume expr -> s2s "Assume" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'
  |    AbsBasilIR.Assert expr -> s2s "Assert" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'


and showCallLVars (e : AbsBasilIR.callLVars) : showable = match e with
       AbsBasilIR.NoOutParams  -> s2s "NoOutParams"
  |    AbsBasilIR.LocalVars lvars -> s2s "LocalVars" >> c2s ' ' >> c2s '(' >> showList showLVar lvars >> c2s ')'
  |    AbsBasilIR.ListOutParams lvars -> s2s "ListOutParams" >> c2s ' ' >> c2s '(' >> showList showLVar lvars >> c2s ')'


and showJump (e : AbsBasilIR.jump) : showable = match e with
       AbsBasilIR.GoTo bidents -> s2s "GoTo" >> c2s ' ' >> c2s '(' >> showList showBIdent bidents >> c2s ')'
  |    AbsBasilIR.Unreachable  -> s2s "Unreachable"
  |    AbsBasilIR.Return exprs -> s2s "Return" >> c2s ' ' >> c2s '(' >> showList showExpr exprs >> c2s ')'


and showLVar (e : AbsBasilIR.lVar) : showable = match e with
       AbsBasilIR.LVarDef (bident, type') -> s2s "LVarDef" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showTypeT type' >> c2s ')'
  |    AbsBasilIR.GlobalLVar (bident, type') -> s2s "GlobalLVar" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showTypeT type' >> c2s ')'


and showBlock (e : AbsBasilIR.block) : showable = match e with
       AbsBasilIR.B (bident, addrattr, beginlist, statements, jump, endlist) -> s2s "B" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showAddrAttr addrattr  >> s2s ", " >>  showBeginList beginlist  >> s2s ", " >>  showList showStatement statements  >> s2s ", " >>  showJump jump  >> s2s ", " >>  showEndList endlist >> c2s ')'


and showPEntry (e : AbsBasilIR.pEntry) : showable = match e with
       AbsBasilIR.EntrySome str -> s2s "EntrySome" >> c2s ' ' >> c2s '(' >> showStr str >> c2s ')'
  |    AbsBasilIR.EntryNone  -> s2s "EntryNone"


and showPAddress (e : AbsBasilIR.pAddress) : showable = match e with
       AbsBasilIR.AddrSome intval -> s2s "AddrSome" >> c2s ' ' >> c2s '(' >> showIntVal intval >> c2s ')'
  |    AbsBasilIR.AddrNone  -> s2s "AddrNone"


and showInternalBlocks (e : AbsBasilIR.internalBlocks) : showable = match e with
       AbsBasilIR.BSome (beginlist, blocks, endlist) -> s2s "BSome" >> c2s ' ' >> c2s '(' >> showBeginList beginlist  >> s2s ", " >>  showList showBlock blocks  >> s2s ", " >>  showEndList endlist >> c2s ')'
  |    AbsBasilIR.BNone  -> s2s "BNone"


and showProcDef (e : AbsBasilIR.procDef) : showable = match e with
       AbsBasilIR.PD (beginrec, str, paddress, pentry, internalblocks, endrec) -> s2s "PD" >> c2s ' ' >> c2s '(' >> showBeginRec beginrec  >> s2s ", " >>  showStr str  >> s2s ", " >>  showPAddress paddress  >> s2s ", " >>  showPEntry pentry  >> s2s ", " >>  showInternalBlocks internalblocks  >> s2s ", " >>  showEndRec endrec >> c2s ')'


and showParams (e : AbsBasilIR.params) : showable = match e with
       AbsBasilIR.Param (bident, type') -> s2s "Param" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showTypeT type' >> c2s ')'


and showExpr (e : AbsBasilIR.expr) : showable = match e with
       AbsBasilIR.RVar (bident, type') -> s2s "RVar" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showTypeT type' >> c2s ')'
  |    AbsBasilIR.BinaryExpr (binop, expr0, expr) -> s2s "BinaryExpr" >> c2s ' ' >> c2s '(' >> showBinOp binop  >> s2s ", " >>  showExpr expr0  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.UnaryExpr (unop, expr) -> s2s "UnaryExpr" >> c2s ' ' >> c2s '(' >> showUnOp unop  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.ZeroExtend (intval, expr) -> s2s "ZeroExtend" >> c2s ' ' >> c2s '(' >> showIntVal intval  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.SignExtend (intval, expr) -> s2s "SignExtend" >> c2s ' ' >> c2s '(' >> showIntVal intval  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.Extract (intval0, intval, expr) -> s2s "Extract" >> c2s ' ' >> c2s '(' >> showIntVal intval0  >> s2s ", " >>  showIntVal intval  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.Concat (expr0, expr) -> s2s "Concat" >> c2s ' ' >> c2s '(' >> showExpr expr0  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.BVLiteral (intval, bvtype) -> s2s "BVLiteral" >> c2s ' ' >> c2s '(' >> showIntVal intval  >> s2s ", " >>  showBVType bvtype >> c2s ')'
  |    AbsBasilIR.IntLiteral intval -> s2s "IntLiteral" >> c2s ' ' >> c2s '(' >> showIntVal intval >> c2s ')'
  |    AbsBasilIR.TrueLiteral  -> s2s "TrueLiteral"
  |    AbsBasilIR.FalseLiteral  -> s2s "FalseLiteral"


and showBinOp (e : AbsBasilIR.binOp) : showable = match e with
       AbsBasilIR.BinOpBVBinOp bvbinop -> s2s "BinOpBVBinOp" >> c2s ' ' >> c2s '(' >> showBVBinOp bvbinop >> c2s ')'
  |    AbsBasilIR.BinOpBVLogicalBinOp bvlogicalbinop -> s2s "BinOpBVLogicalBinOp" >> c2s ' ' >> c2s '(' >> showBVLogicalBinOp bvlogicalbinop >> c2s ')'
  |    AbsBasilIR.BinOpBoolBinOp boolbinop -> s2s "BinOpBoolBinOp" >> c2s ' ' >> c2s '(' >> showBoolBinOp boolbinop >> c2s ')'
  |    AbsBasilIR.BinOpIntLogicalBinOp intlogicalbinop -> s2s "BinOpIntLogicalBinOp" >> c2s ' ' >> c2s '(' >> showIntLogicalBinOp intlogicalbinop >> c2s ')'
  |    AbsBasilIR.BinOpIntBinOp intbinop -> s2s "BinOpIntBinOp" >> c2s ' ' >> c2s '(' >> showIntBinOp intbinop >> c2s ')'


and showUnOp (e : AbsBasilIR.unOp) : showable = match e with
       AbsBasilIR.UnOpBVUnOp bvunop -> s2s "UnOpBVUnOp" >> c2s ' ' >> c2s '(' >> showBVUnOp bvunop >> c2s ')'
  |    AbsBasilIR.UnOp_boolnot  -> s2s "UnOp_boolnot"
  |    AbsBasilIR.UnOp_intneg  -> s2s "UnOp_intneg"


and showBVUnOp (e : AbsBasilIR.bVUnOp) : showable = match e with
       AbsBasilIR.BVUnOp_bvnot  -> s2s "BVUnOp_bvnot"
  |    AbsBasilIR.BVUnOp_bvneg  -> s2s "BVUnOp_bvneg"


and showBVBinOp (e : AbsBasilIR.bVBinOp) : showable = match e with
       AbsBasilIR.BVBinOp_bvand  -> s2s "BVBinOp_bvand"
  |    AbsBasilIR.BVBinOp_bvor  -> s2s "BVBinOp_bvor"
  |    AbsBasilIR.BVBinOp_bvadd  -> s2s "BVBinOp_bvadd"
  |    AbsBasilIR.BVBinOp_bvmul  -> s2s "BVBinOp_bvmul"
  |    AbsBasilIR.BVBinOp_bvudiv  -> s2s "BVBinOp_bvudiv"
  |    AbsBasilIR.BVBinOp_bvurem  -> s2s "BVBinOp_bvurem"
  |    AbsBasilIR.BVBinOp_bvshl  -> s2s "BVBinOp_bvshl"
  |    AbsBasilIR.BVBinOp_bvlshr  -> s2s "BVBinOp_bvlshr"
  |    AbsBasilIR.BVBinOp_bvult  -> s2s "BVBinOp_bvult"
  |    AbsBasilIR.BVBinOp_bvnand  -> s2s "BVBinOp_bvnand"
  |    AbsBasilIR.BVBinOp_bvnor  -> s2s "BVBinOp_bvnor"
  |    AbsBasilIR.BVBinOp_bvxor  -> s2s "BVBinOp_bvxor"
  |    AbsBasilIR.BVBinOp_bvxnor  -> s2s "BVBinOp_bvxnor"
  |    AbsBasilIR.BVBinOp_bvcomp  -> s2s "BVBinOp_bvcomp"
  |    AbsBasilIR.BVBinOp_bvsub  -> s2s "BVBinOp_bvsub"
  |    AbsBasilIR.BVBinOp_bvsdiv  -> s2s "BVBinOp_bvsdiv"
  |    AbsBasilIR.BVBinOp_bvsrem  -> s2s "BVBinOp_bvsrem"
  |    AbsBasilIR.BVBinOp_bvsmod  -> s2s "BVBinOp_bvsmod"
  |    AbsBasilIR.BVBinOp_bvashr  -> s2s "BVBinOp_bvashr"


and showBVLogicalBinOp (e : AbsBasilIR.bVLogicalBinOp) : showable = match e with
       AbsBasilIR.BVLogicalBinOp_bvule  -> s2s "BVLogicalBinOp_bvule"
  |    AbsBasilIR.BVLogicalBinOp_bvugt  -> s2s "BVLogicalBinOp_bvugt"
  |    AbsBasilIR.BVLogicalBinOp_bvuge  -> s2s "BVLogicalBinOp_bvuge"
  |    AbsBasilIR.BVLogicalBinOp_bvslt  -> s2s "BVLogicalBinOp_bvslt"
  |    AbsBasilIR.BVLogicalBinOp_bvsle  -> s2s "BVLogicalBinOp_bvsle"
  |    AbsBasilIR.BVLogicalBinOp_bvsgt  -> s2s "BVLogicalBinOp_bvsgt"
  |    AbsBasilIR.BVLogicalBinOp_bvsge  -> s2s "BVLogicalBinOp_bvsge"
  |    AbsBasilIR.BVLogicalBinOp_bveq  -> s2s "BVLogicalBinOp_bveq"
  |    AbsBasilIR.BVLogicalBinOp_bvneq  -> s2s "BVLogicalBinOp_bvneq"


and showIntBinOp (e : AbsBasilIR.intBinOp) : showable = match e with
       AbsBasilIR.IntBinOp_intadd  -> s2s "IntBinOp_intadd"
  |    AbsBasilIR.IntBinOp_intmul  -> s2s "IntBinOp_intmul"
  |    AbsBasilIR.IntBinOp_intsub  -> s2s "IntBinOp_intsub"
  |    AbsBasilIR.IntBinOp_intdiv  -> s2s "IntBinOp_intdiv"
  |    AbsBasilIR.IntBinOp_intmod  -> s2s "IntBinOp_intmod"


and showIntLogicalBinOp (e : AbsBasilIR.intLogicalBinOp) : showable = match e with
       AbsBasilIR.IntLogicalBinOp_inteq  -> s2s "IntLogicalBinOp_inteq"
  |    AbsBasilIR.IntLogicalBinOp_intneq  -> s2s "IntLogicalBinOp_intneq"
  |    AbsBasilIR.IntLogicalBinOp_intlt  -> s2s "IntLogicalBinOp_intlt"
  |    AbsBasilIR.IntLogicalBinOp_intle  -> s2s "IntLogicalBinOp_intle"
  |    AbsBasilIR.IntLogicalBinOp_intgt  -> s2s "IntLogicalBinOp_intgt"
  |    AbsBasilIR.IntLogicalBinOp_intge  -> s2s "IntLogicalBinOp_intge"


and showBoolBinOp (e : AbsBasilIR.boolBinOp) : showable = match e with
       AbsBasilIR.BoolBinOp_booleq  -> s2s "BoolBinOp_booleq"
  |    AbsBasilIR.BoolBinOp_boolneq  -> s2s "BoolBinOp_boolneq"
  |    AbsBasilIR.BoolBinOp_booland  -> s2s "BoolBinOp_booland"
  |    AbsBasilIR.BoolBinOp_boolor  -> s2s "BoolBinOp_boolor"
  |    AbsBasilIR.BoolBinOp_boolimplies  -> s2s "BoolBinOp_boolimplies"
  |    AbsBasilIR.BoolBinOp_boolequiv  -> s2s "BoolBinOp_boolequiv"




(* File generated by the BNF Converter (bnfc 2.9.5). *)

(* show functions *)

(* use string buffers for efficient string concatenations *)
type showable = Buffer.t -> unit

let show (s : showable) : string =
    let init_size = 16 in (* you may want to adjust this *)
    let b = Buffer.create init_size in
    s b;
    Buffer.contents b

let emptyS : showable = fun buf -> ()

let c2s (c:char) : showable = fun buf -> Buffer.add_char buf c
let s2s (s:string) : showable = fun buf -> Buffer.add_string buf s

let ( >> ) (s1 : showable) (s2 : showable) : showable = fun buf -> s1 buf; s2 buf

let showChar (c:char) : showable = fun buf ->
    Buffer.add_string buf ("'" ^ Char.escaped c ^ "'")

let showString (s:string) : showable = fun buf ->
    Buffer.add_string buf ("\"" ^ String.escaped s ^ "\"")

let showList (showFun : 'a -> showable) (xs : 'a list) : showable = fun buf ->
    let rec f ys = match ys with
        [] -> ()
      | [y] -> showFun y buf
      | y::ys -> showFun y buf; Buffer.add_string buf "; "; f ys
    in
        Buffer.add_char buf '[';
        f xs;
        Buffer.add_char buf ']'


let showInt (i:int) : showable = s2s (string_of_int i)
let showFloat (f:float) : showable = s2s (string_of_float f)

let rec showBVTYPE (AbsBasilIR.BVTYPE i) : showable = s2s "BVTYPE " >> showString i
let rec showUserIdent (AbsBasilIR.UserIdent (_,i)) : showable = s2s "UserIdent " >> showString i
let rec showBIdent (AbsBasilIR.BIdent (_,i)) : showable = s2s "BIdent " >> showString i
let rec showLocalIdent (AbsBasilIR.LocalIdent (_,i)) : showable = s2s "LocalIdent " >> showString i
let rec showGlobalIdent (AbsBasilIR.GlobalIdent (_,i)) : showable = s2s "GlobalIdent " >> showString i
let rec showBlockIdent (AbsBasilIR.BlockIdent (_,i)) : showable = s2s "BlockIdent " >> showString i
let rec showProcIdent (AbsBasilIR.ProcIdent (_,i)) : showable = s2s "ProcIdent " >> showString i
let rec showBeginList (AbsBasilIR.BeginList (_,i)) : showable = s2s "BeginList " >> showString i
let rec showEndList (AbsBasilIR.EndList (_,i)) : showable = s2s "EndList " >> showString i
let rec showBeginRec (AbsBasilIR.BeginRec (_,i)) : showable = s2s "BeginRec " >> showString i
let rec showEndRec (AbsBasilIR.EndRec (_,i)) : showable = s2s "EndRec " >> showString i
let rec showStr (AbsBasilIR.Str i) : showable = s2s "Str " >> showString i
let rec showIntegerHex (AbsBasilIR.IntegerHex i) : showable = s2s "IntegerHex " >> showString i
let rec showBitvectorHex (AbsBasilIR.BitvectorHex i) : showable = s2s "BitvectorHex " >> showString i

let rec showProgram (e : AbsBasilIR.program) : showable = match e with
       AbsBasilIR.Prog declarations -> s2s "Prog" >> c2s ' ' >> c2s '(' >> showList showDeclaration declarations >> c2s ')'


and showDeclaration (e : AbsBasilIR.declaration) : showable = match e with
       AbsBasilIR.AxiomDecl (attrdeflist, expr) -> s2s "AxiomDecl" >> c2s ' ' >> c2s '(' >> showAttrDefList attrdeflist  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.MemDecl (globalident, type') -> s2s "MemDecl" >> c2s ' ' >> c2s '(' >> showGlobalIdent globalident  >> s2s ", " >>  showTypeT type' >> c2s ')'
  |    AbsBasilIR.VarDecl (globalident, type') -> s2s "VarDecl" >> c2s ' ' >> c2s '(' >> showGlobalIdent globalident  >> s2s ", " >>  showTypeT type' >> c2s ')'
  |    AbsBasilIR.ProgDecl (attrdeflist, thrspecdecls) -> s2s "ProgDecl" >> c2s ' ' >> c2s '(' >> showAttrDefList attrdeflist  >> s2s ", " >>  showList showThrSpecDecl thrspecdecls >> c2s ')'
  |    AbsBasilIR.Procedure procdef -> s2s "Procedure" >> c2s ' ' >> c2s '(' >> showProcDef procdef >> c2s ')'


and showIntType (e : AbsBasilIR.intType) : showable = match e with
       AbsBasilIR.IntT  -> s2s "IntT"


and showBoolType (e : AbsBasilIR.boolType) : showable = match e with
       AbsBasilIR.BoolT  -> s2s "BoolT"


and showMapType (e : AbsBasilIR.mapType) : showable = match e with
       AbsBasilIR.MapT (type'0, beginlist, type', endlist) -> s2s "MapT" >> c2s ' ' >> c2s '(' >> showTypeT type'0  >> s2s ", " >>  showBeginList beginlist  >> s2s ", " >>  showTypeT type'  >> s2s ", " >>  showEndList endlist >> c2s ')'


and showBVType (e : AbsBasilIR.bVType) : showable = match e with
       AbsBasilIR.BVT bvtype -> s2s "BVT" >> c2s ' ' >> c2s '(' >> showBVTYPE bvtype >> c2s ')'


and showTypeT (e : AbsBasilIR.typeT) : showable = match e with
       AbsBasilIR.TypeIntType inttype -> s2s "TypeIntType" >> c2s ' ' >> c2s '(' >> showIntType inttype >> c2s ')'
  |    AbsBasilIR.TypeBoolType booltype -> s2s "TypeBoolType" >> c2s ' ' >> c2s '(' >> showBoolType booltype >> c2s ')'
  |    AbsBasilIR.TypeMapType maptype -> s2s "TypeMapType" >> c2s ' ' >> c2s '(' >> showMapType maptype >> c2s ')'
  |    AbsBasilIR.TypeBVType bvtype -> s2s "TypeBVType" >> c2s ' ' >> c2s '(' >> showBVType bvtype >> c2s ')'


and showIntVal (e : AbsBasilIR.intVal) : showable = match e with
       AbsBasilIR.HexInt integerhex -> s2s "HexInt" >> c2s ' ' >> c2s '(' >> showIntegerHex integerhex >> c2s ')'
  |    AbsBasilIR.DecInt integer -> s2s "DecInt" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'


and showBVVal (e : AbsBasilIR.bVVal) : showable = match e with
       AbsBasilIR.BV (intval, bvtype) -> s2s "BV" >> c2s ' ' >> c2s '(' >> showIntVal intval  >> s2s ", " >>  showBVType bvtype >> c2s ')'


and showEndian (e : AbsBasilIR.endian) : showable = match e with
       AbsBasilIR.LittleEndian  -> s2s "LittleEndian"
  |    AbsBasilIR.BigEndian  -> s2s "BigEndian"


and showAssignment (e : AbsBasilIR.assignment) : showable = match e with
       AbsBasilIR.Assignment1 (lvar, expr) -> s2s "Assignment1" >> c2s ' ' >> c2s '(' >> showLVar lvar  >> s2s ", " >>  showExpr expr >> c2s ')'


and showStatement (e : AbsBasilIR.statement) : showable = match e with
       AbsBasilIR.Assign assignment -> s2s "Assign" >> c2s ' ' >> c2s '(' >> showAssignment assignment >> c2s ')'
  |    AbsBasilIR.SimulAssign assignments -> s2s "SimulAssign" >> c2s ' ' >> c2s '(' >> showList showAssignment assignments >> c2s ')'
  |    AbsBasilIR.SLoad (lvar, endian, globalident, expr, intval) -> s2s "SLoad" >> c2s ' ' >> c2s '(' >> showLVar lvar  >> s2s ", " >>  showEndian endian  >> s2s ", " >>  showGlobalIdent globalident  >> s2s ", " >>  showExpr expr  >> s2s ", " >>  showIntVal intval >> c2s ')'
  |    AbsBasilIR.SStore (endian, globalident, expr0, expr, intval) -> s2s "SStore" >> c2s ' ' >> c2s '(' >> showEndian endian  >> s2s ", " >>  showGlobalIdent globalident  >> s2s ", " >>  showExpr expr0  >> s2s ", " >>  showExpr expr  >> s2s ", " >>  showIntVal intval >> c2s ')'
  |    AbsBasilIR.DirectCall (calllvars, procident, exprs) -> s2s "DirectCall" >> c2s ' ' >> c2s '(' >> showCallLVars calllvars  >> s2s ", " >>  showProcIdent procident  >> s2s ", " >>  showList showExpr exprs >> c2s ')'
  |    AbsBasilIR.IndirectCall expr -> s2s "IndirectCall" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'
  |    AbsBasilIR.Assume expr -> s2s "Assume" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'
  |    AbsBasilIR.Assert expr -> s2s "Assert" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'


and showLocalVar (e : AbsBasilIR.localVar) : showable = match e with
       AbsBasilIR.LocalVar1 (localident, type') -> s2s "LocalVar1" >> c2s ' ' >> c2s '(' >> showLocalIdent localident  >> s2s ", " >>  showTypeT type' >> c2s ')'


and showGlobalVar (e : AbsBasilIR.globalVar) : showable = match e with
       AbsBasilIR.GlobalVar1 (globalident, type') -> s2s "GlobalVar1" >> c2s ' ' >> c2s '(' >> showGlobalIdent globalident  >> s2s ", " >>  showTypeT type' >> c2s ')'


and showCallLVars (e : AbsBasilIR.callLVars) : showable = match e with
       AbsBasilIR.NoOutParams  -> s2s "NoOutParams"
  |    AbsBasilIR.LocalVars localvars -> s2s "LocalVars" >> c2s ' ' >> c2s '(' >> showList showLocalVar localvars >> c2s ')'
  |    AbsBasilIR.ListOutParams lvars -> s2s "ListOutParams" >> c2s ' ' >> c2s '(' >> showList showLVar lvars >> c2s ')'


and showJump (e : AbsBasilIR.jump) : showable = match e with
       AbsBasilIR.GoTo blockidents -> s2s "GoTo" >> c2s ' ' >> c2s '(' >> showList showBlockIdent blockidents >> c2s ')'
  |    AbsBasilIR.Unreachable  -> s2s "Unreachable"
  |    AbsBasilIR.Return exprs -> s2s "Return" >> c2s ' ' >> c2s '(' >> showList showExpr exprs >> c2s ')'


and showLVar (e : AbsBasilIR.lVar) : showable = match e with
       AbsBasilIR.LVarDef localvar -> s2s "LVarDef" >> c2s ' ' >> c2s '(' >> showLocalVar localvar >> c2s ')'
  |    AbsBasilIR.GlobalLVar globalvar -> s2s "GlobalLVar" >> c2s ' ' >> c2s '(' >> showGlobalVar globalvar >> c2s ')'


and showBlock (e : AbsBasilIR.block) : showable = match e with
       AbsBasilIR.Block1 (blockident, attrdeflist, beginlist, statements, jump, endlist) -> s2s "Block1" >> c2s ' ' >> c2s '(' >> showBlockIdent blockident  >> s2s ", " >>  showAttrDefList attrdeflist  >> s2s ", " >>  showBeginList beginlist  >> s2s ", " >>  showList showStatement statements  >> s2s ", " >>  showJump jump  >> s2s ", " >>  showEndList endlist >> c2s ')'


and showAttributeItem (e : AbsBasilIR.attributeItem) : showable = match e with
       AbsBasilIR.IntAttr (bident, intval) -> s2s "IntAttr" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showIntVal intval >> c2s ')'
  |    AbsBasilIR.BVAttr (bident, bvval) -> s2s "BVAttr" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showBVVal bvval >> c2s ')'
  |    AbsBasilIR.ExprAttr (bident, expr) -> s2s "ExprAttr" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.StringAttr (bident, str) -> s2s "StringAttr" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showStr str >> c2s ')'


and showAttrDefList (e : AbsBasilIR.attrDefList) : showable = match e with
       AbsBasilIR.AttrDefListSome (beginrec, attributeitems, endrec) -> s2s "AttrDefListSome" >> c2s ' ' >> c2s '(' >> showBeginRec beginrec  >> s2s ", " >>  showList showAttributeItem attributeitems  >> s2s ", " >>  showEndRec endrec >> c2s ')'
  |    AbsBasilIR.AttrDefListEmpty  -> s2s "AttrDefListEmpty"


and showParams (e : AbsBasilIR.params) : showable = match e with
       AbsBasilIR.Param (localident, type') -> s2s "Param" >> c2s ' ' >> c2s '(' >> showLocalIdent localident  >> s2s ", " >>  showTypeT type' >> c2s ')'


and showProcSig (e : AbsBasilIR.procSig) : showable = match e with
       AbsBasilIR.ProcedureSig (procident, paramss0, paramss) -> s2s "ProcedureSig" >> c2s ' ' >> c2s '(' >> showProcIdent procident  >> s2s ", " >>  showList showParams paramss0  >> s2s ", " >>  showList showParams paramss >> c2s ')'


and showProcDef (e : AbsBasilIR.procDef) : showable = match e with
       AbsBasilIR.ProcedureDecl (procsig, attrdeflist) -> s2s "ProcedureDecl" >> c2s ' ' >> c2s '(' >> showProcSig procsig  >> s2s ", " >>  showAttrDefList attrdeflist >> c2s ')'
  |    AbsBasilIR.ProcedureDef (procsig, attrdeflist, beginlist, blocks, endlist) -> s2s "ProcedureDef" >> c2s ' ' >> c2s '(' >> showProcSig procsig  >> s2s ", " >>  showAttrDefList attrdeflist  >> s2s ", " >>  showBeginList beginlist  >> s2s ", " >>  showList showBlock blocks  >> s2s ", " >>  showEndList endlist >> c2s ')'


and showExpr (e : AbsBasilIR.expr) : showable = match e with
       AbsBasilIR.BVLiteral bvval -> s2s "BVLiteral" >> c2s ' ' >> c2s '(' >> showBVVal bvval >> c2s ')'
  |    AbsBasilIR.IntLiteral intval -> s2s "IntLiteral" >> c2s ' ' >> c2s '(' >> showIntVal intval >> c2s ')'
  |    AbsBasilIR.TrueLiteral  -> s2s "TrueLiteral"
  |    AbsBasilIR.FalseLiteral  -> s2s "FalseLiteral"
  |    AbsBasilIR.LRVar localvar -> s2s "LRVar" >> c2s ' ' >> c2s '(' >> showLocalVar localvar >> c2s ')'
  |    AbsBasilIR.GRVar globalvar -> s2s "GRVar" >> c2s ' ' >> c2s '(' >> showGlobalVar globalvar >> c2s ')'
  |    AbsBasilIR.FunctionOp (globalident, exprs) -> s2s "FunctionOp" >> c2s ' ' >> c2s '(' >> showGlobalIdent globalident  >> s2s ", " >>  showList showExpr exprs >> c2s ')'


and showEqOp (e : AbsBasilIR.eqOp) : showable = match e with
       AbsBasilIR.EqOp_eq  -> s2s "EqOp_eq"
  |    AbsBasilIR.EqOp_neq  -> s2s "EqOp_neq"


and showBVUnOp (e : AbsBasilIR.bVUnOp) : showable = match e with
       AbsBasilIR.BVUnOp_bvnot  -> s2s "BVUnOp_bvnot"
  |    AbsBasilIR.BVUnOp_bvneg  -> s2s "BVUnOp_bvneg"


and showBVBinOp (e : AbsBasilIR.bVBinOp) : showable = match e with
       AbsBasilIR.BVBinOp_bvand  -> s2s "BVBinOp_bvand"
  |    AbsBasilIR.BVBinOp_bvor  -> s2s "BVBinOp_bvor"
  |    AbsBasilIR.BVBinOp_bvadd  -> s2s "BVBinOp_bvadd"
  |    AbsBasilIR.BVBinOp_bvmul  -> s2s "BVBinOp_bvmul"
  |    AbsBasilIR.BVBinOp_bvudiv  -> s2s "BVBinOp_bvudiv"
  |    AbsBasilIR.BVBinOp_bvurem  -> s2s "BVBinOp_bvurem"
  |    AbsBasilIR.BVBinOp_bvshl  -> s2s "BVBinOp_bvshl"
  |    AbsBasilIR.BVBinOp_bvlshr  -> s2s "BVBinOp_bvlshr"
  |    AbsBasilIR.BVBinOp_bvnand  -> s2s "BVBinOp_bvnand"
  |    AbsBasilIR.BVBinOp_bvnor  -> s2s "BVBinOp_bvnor"
  |    AbsBasilIR.BVBinOp_bvxor  -> s2s "BVBinOp_bvxor"
  |    AbsBasilIR.BVBinOp_bvxnor  -> s2s "BVBinOp_bvxnor"
  |    AbsBasilIR.BVBinOp_bvcomp  -> s2s "BVBinOp_bvcomp"
  |    AbsBasilIR.BVBinOp_bvsub  -> s2s "BVBinOp_bvsub"
  |    AbsBasilIR.BVBinOp_bvsdiv  -> s2s "BVBinOp_bvsdiv"
  |    AbsBasilIR.BVBinOp_bvsrem  -> s2s "BVBinOp_bvsrem"
  |    AbsBasilIR.BVBinOp_bvsmod  -> s2s "BVBinOp_bvsmod"
  |    AbsBasilIR.BVBinOp_bvashr  -> s2s "BVBinOp_bvashr"


and showBVLogicalBinOp (e : AbsBasilIR.bVLogicalBinOp) : showable = match e with
       AbsBasilIR.BVLogicalBinOp_bvule  -> s2s "BVLogicalBinOp_bvule"
  |    AbsBasilIR.BVLogicalBinOp_bvugt  -> s2s "BVLogicalBinOp_bvugt"
  |    AbsBasilIR.BVLogicalBinOp_bvuge  -> s2s "BVLogicalBinOp_bvuge"
  |    AbsBasilIR.BVLogicalBinOp_bvult  -> s2s "BVLogicalBinOp_bvult"
  |    AbsBasilIR.BVLogicalBinOp_bvslt  -> s2s "BVLogicalBinOp_bvslt"
  |    AbsBasilIR.BVLogicalBinOp_bvsle  -> s2s "BVLogicalBinOp_bvsle"
  |    AbsBasilIR.BVLogicalBinOp_bvsgt  -> s2s "BVLogicalBinOp_bvsgt"
  |    AbsBasilIR.BVLogicalBinOp_bvsge  -> s2s "BVLogicalBinOp_bvsge"


and showIntBinOp (e : AbsBasilIR.intBinOp) : showable = match e with
       AbsBasilIR.IntBinOp_intadd  -> s2s "IntBinOp_intadd"
  |    AbsBasilIR.IntBinOp_intmul  -> s2s "IntBinOp_intmul"
  |    AbsBasilIR.IntBinOp_intsub  -> s2s "IntBinOp_intsub"
  |    AbsBasilIR.IntBinOp_intdiv  -> s2s "IntBinOp_intdiv"
  |    AbsBasilIR.IntBinOp_intmod  -> s2s "IntBinOp_intmod"


and showIntLogicalBinOp (e : AbsBasilIR.intLogicalBinOp) : showable = match e with
       AbsBasilIR.IntLogicalBinOp_intlt  -> s2s "IntLogicalBinOp_intlt"
  |    AbsBasilIR.IntLogicalBinOp_intle  -> s2s "IntLogicalBinOp_intle"
  |    AbsBasilIR.IntLogicalBinOp_intgt  -> s2s "IntLogicalBinOp_intgt"
  |    AbsBasilIR.IntLogicalBinOp_intge  -> s2s "IntLogicalBinOp_intge"


and showBoolBinOp (e : AbsBasilIR.boolBinOp) : showable = match e with
       AbsBasilIR.BoolBinOp_booland  -> s2s "BoolBinOp_booland"
  |    AbsBasilIR.BoolBinOp_boolor  -> s2s "BoolBinOp_boolor"
  |    AbsBasilIR.BoolBinOp_boolimplies  -> s2s "BoolBinOp_boolimplies"


and showFunSpecDecl (e : AbsBasilIR.funSpecDecl) : showable = match e with
       AbsBasilIR.Require expr -> s2s "Require" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'
  |    AbsBasilIR.Ensure expr -> s2s "Ensure" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'
  |    AbsBasilIR.LoopInvariant (blockident, expr) -> s2s "LoopInvariant" >> c2s ' ' >> c2s '(' >> showBlockIdent blockident  >> s2s ", " >>  showExpr expr >> c2s ')'


and showThrSpecDecl (e : AbsBasilIR.thrSpecDecl) : showable = match e with
       AbsBasilIR.Rely expr -> s2s "Rely" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'
  |    AbsBasilIR.Guarantee expr -> s2s "Guarantee" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'




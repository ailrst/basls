(* File generated by the BNF Converter (bnfc 2.9.5). *)

(* show functions *)

(* use string buffers for efficient string concatenations *)
type showable = Buffer.t -> unit

let show (s : showable) : string =
    let init_size = 16 in (* you may want to adjust this *)
    let b = Buffer.create init_size in
    s b;
    Buffer.contents b

let emptyS : showable = fun buf -> ()

let c2s (c:char) : showable = fun buf -> Buffer.add_char buf c
let s2s (s:string) : showable = fun buf -> Buffer.add_string buf s

let ( >> ) (s1 : showable) (s2 : showable) : showable = fun buf -> s1 buf; s2 buf

let showChar (c:char) : showable = fun buf ->
    Buffer.add_string buf ("'" ^ Char.escaped c ^ "'")

let showString (s:string) : showable = fun buf ->
    Buffer.add_string buf ("\"" ^ String.escaped s ^ "\"")

let showList (showFun : 'a -> showable) (xs : 'a list) : showable = fun buf ->
    let rec f ys = match ys with
        [] -> ()
      | [y] -> showFun y buf
      | y::ys -> showFun y buf; Buffer.add_string buf "; "; f ys
    in
        Buffer.add_char buf '[';
        f xs;
        Buffer.add_char buf ']'


let showInt (i:int) : showable = s2s (string_of_int i)
let showFloat (f:float) : showable = s2s (string_of_float f)

let rec showBVTYPE (AbsBasilIR.BVTYPE i) : showable = s2s "BVTYPE " >> showString i
let rec showINTTYPE (AbsBasilIR.INTTYPE (_,i)) : showable = s2s "INTTYPE " >> showString i
let rec showBOOLTYPE (AbsBasilIR.BOOLTYPE (_,i)) : showable = s2s "BOOLTYPE " >> showString i
let rec showBIdent (AbsBasilIR.BIdent (_,i)) : showable = s2s "BIdent " >> showString i
let rec showLocalIdent (AbsBasilIR.LocalIdent (_,i)) : showable = s2s "LocalIdent " >> showString i
let rec showGlobalIdent (AbsBasilIR.GlobalIdent (_,i)) : showable = s2s "GlobalIdent " >> showString i
let rec showBlockIdent (AbsBasilIR.BlockIdent (_,i)) : showable = s2s "BlockIdent " >> showString i
let rec showProcIdent (AbsBasilIR.ProcIdent (_,i)) : showable = s2s "ProcIdent " >> showString i
let rec showBeginList (AbsBasilIR.BeginList (_,i)) : showable = s2s "BeginList " >> showString i
let rec showEndList (AbsBasilIR.EndList (_,i)) : showable = s2s "EndList " >> showString i
let rec showBeginRec (AbsBasilIR.BeginRec (_,i)) : showable = s2s "BeginRec " >> showString i
let rec showEndRec (AbsBasilIR.EndRec (_,i)) : showable = s2s "EndRec " >> showString i
let rec showLambdaSep (AbsBasilIR.LambdaSep i) : showable = s2s "LambdaSep " >> showString i
let rec showStr (AbsBasilIR.Str i) : showable = s2s "Str " >> showString i
let rec showIntegerHex (AbsBasilIR.IntegerHex i) : showable = s2s "IntegerHex " >> showString i
let rec showIntegerDec (AbsBasilIR.IntegerDec i) : showable = s2s "IntegerDec " >> showString i

let rec showModuleT (e : AbsBasilIR.moduleT) : showable = match e with
       AbsBasilIR.Module1 decls -> s2s "Module1" >> c2s ' ' >> c2s '(' >> showList showDecl decls >> c2s ')'


and showSemicolons (e : AbsBasilIR.semicolons) : showable = match e with
       AbsBasilIR.Semicolons_Empty  -> s2s "Semicolons_Empty"
  |    AbsBasilIR.Semicolons_Some semicolons -> s2s "Semicolons_Some" >> c2s ' ' >> c2s '(' >> showSemicolons semicolons >> c2s ')'


and showDecl (e : AbsBasilIR.decl) : showable = match e with
       AbsBasilIR.Decl_Axiom (attribset, expr) -> s2s "Decl_Axiom" >> c2s ' ' >> c2s '(' >> showAttribSet attribset  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.Decl_SharedMem (globalident, type') -> s2s "Decl_SharedMem" >> c2s ' ' >> c2s '(' >> showGlobalIdent globalident  >> s2s ", " >>  showTypeT type' >> c2s ')'
  |    AbsBasilIR.Decl_UnsharedMem (globalident, type') -> s2s "Decl_UnsharedMem" >> c2s ' ' >> c2s '(' >> showGlobalIdent globalident  >> s2s ", " >>  showTypeT type' >> c2s ')'
  |    AbsBasilIR.Decl_Var (globalident, type') -> s2s "Decl_Var" >> c2s ' ' >> c2s '(' >> showGlobalIdent globalident  >> s2s ", " >>  showTypeT type' >> c2s ')'
  |    AbsBasilIR.Decl_UninterpFun (attribset, globalident, types, type') -> s2s "Decl_UninterpFun" >> c2s ' ' >> c2s '(' >> showAttribSet attribset  >> s2s ", " >>  showGlobalIdent globalident  >> s2s ", " >>  showList showTypeT types  >> s2s ", " >>  showTypeT type' >> c2s ')'
  |    AbsBasilIR.Decl_Fun (attribset, globalident, paramss, type', expr) -> s2s "Decl_Fun" >> c2s ' ' >> c2s '(' >> showAttribSet attribset  >> s2s ", " >>  showGlobalIdent globalident  >> s2s ", " >>  showList showParams paramss  >> s2s ", " >>  showTypeT type'  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.Decl_ProgEmpty (procident, attribset) -> s2s "Decl_ProgEmpty" >> c2s ' ' >> c2s '(' >> showProcIdent procident  >> s2s ", " >>  showAttribSet attribset >> c2s ')'
  |    AbsBasilIR.Decl_ProgWithSpec (procident, attribset, beginlist, progspecs, endlist) -> s2s "Decl_ProgWithSpec" >> c2s ' ' >> c2s '(' >> showProcIdent procident  >> s2s ", " >>  showAttribSet attribset  >> s2s ", " >>  showBeginList beginlist  >> s2s ", " >>  showList showProgSpec progspecs  >> s2s ", " >>  showEndList endlist >> c2s ')'
  |    AbsBasilIR.Decl_Proc (procident, paramss0, paramss, attribset, funspecs, procdef) -> s2s "Decl_Proc" >> c2s ' ' >> c2s '(' >> showProcIdent procident  >> s2s ", " >>  showList showParams paramss0  >> s2s ", " >>  showList showParams paramss  >> s2s ", " >>  showAttribSet attribset  >> s2s ", " >>  showList showFunSpec funspecs  >> s2s ", " >>  showProcDef procdef >> c2s ')'


and showProcDef (e : AbsBasilIR.procDef) : showable = match e with
       AbsBasilIR.ProcDef_Empty  -> s2s "ProcDef_Empty"
  |    AbsBasilIR.ProcDef_Some (beginlist, blocks, endlist) -> s2s "ProcDef_Some" >> c2s ' ' >> c2s '(' >> showBeginList beginlist  >> s2s ", " >>  showList showBlock blocks  >> s2s ", " >>  showEndList endlist >> c2s ')'


and showIntType (e : AbsBasilIR.intType) : showable = match e with
       AbsBasilIR.IntType1 inttype -> s2s "IntType1" >> c2s ' ' >> c2s '(' >> showINTTYPE inttype >> c2s ')'


and showBoolType (e : AbsBasilIR.boolType) : showable = match e with
       AbsBasilIR.BoolType1 booltype -> s2s "BoolType1" >> c2s ' ' >> c2s '(' >> showBOOLTYPE booltype >> c2s ')'


and showMapType (e : AbsBasilIR.mapType) : showable = match e with
       AbsBasilIR.MapType1 (type'0, type') -> s2s "MapType1" >> c2s ' ' >> c2s '(' >> showTypeT type'0  >> s2s ", " >>  showTypeT type' >> c2s ')'


and showBVType (e : AbsBasilIR.bVType) : showable = match e with
       AbsBasilIR.BVType1 bvtype -> s2s "BVType1" >> c2s ' ' >> c2s '(' >> showBVTYPE bvtype >> c2s ')'


and showTypeT (e : AbsBasilIR.typeT) : showable = match e with
       AbsBasilIR.TypeIntType inttype -> s2s "TypeIntType" >> c2s ' ' >> c2s '(' >> showIntType inttype >> c2s ')'
  |    AbsBasilIR.TypeBoolType booltype -> s2s "TypeBoolType" >> c2s ' ' >> c2s '(' >> showBoolType booltype >> c2s ')'
  |    AbsBasilIR.TypeMapType maptype -> s2s "TypeMapType" >> c2s ' ' >> c2s '(' >> showMapType maptype >> c2s ')'
  |    AbsBasilIR.TypeBVType bvtype -> s2s "TypeBVType" >> c2s ' ' >> c2s '(' >> showBVType bvtype >> c2s ')'


and showIntVal (e : AbsBasilIR.intVal) : showable = match e with
       AbsBasilIR.IntVal_Hex integerhex -> s2s "IntVal_Hex" >> c2s ' ' >> c2s '(' >> showIntegerHex integerhex >> c2s ')'
  |    AbsBasilIR.IntVal_Dec integerdec -> s2s "IntVal_Dec" >> c2s ' ' >> c2s '(' >> showIntegerDec integerdec >> c2s ')'


and showBVVal (e : AbsBasilIR.bVVal) : showable = match e with
       AbsBasilIR.BVVal1 (intval, bvtype) -> s2s "BVVal1" >> c2s ' ' >> c2s '(' >> showIntVal intval  >> s2s ", " >>  showBVType bvtype >> c2s ')'


and showEndian (e : AbsBasilIR.endian) : showable = match e with
       AbsBasilIR.Endian_Little  -> s2s "Endian_Little"
  |    AbsBasilIR.Endian_Big  -> s2s "Endian_Big"


and showAssignment (e : AbsBasilIR.assignment) : showable = match e with
       AbsBasilIR.Assignment1 (lvar, expr) -> s2s "Assignment1" >> c2s ' ' >> c2s '(' >> showLVar lvar  >> s2s ", " >>  showExpr expr >> c2s ')'


and showStmt (e : AbsBasilIR.stmt) : showable = match e with
       AbsBasilIR.Stmt_SingleAssign assignment -> s2s "Stmt_SingleAssign" >> c2s ' ' >> c2s '(' >> showAssignment assignment >> c2s ')'
  |    AbsBasilIR.Stmt_MultiAssign assignments -> s2s "Stmt_MultiAssign" >> c2s ' ' >> c2s '(' >> showList showAssignment assignments >> c2s ')'
  |    AbsBasilIR.Stmt_Load (lvar, endian, globalident, expr, intval) -> s2s "Stmt_Load" >> c2s ' ' >> c2s '(' >> showLVar lvar  >> s2s ", " >>  showEndian endian  >> s2s ", " >>  showGlobalIdent globalident  >> s2s ", " >>  showExpr expr  >> s2s ", " >>  showIntVal intval >> c2s ')'
  |    AbsBasilIR.Stmt_Store (endian, globalident, expr0, expr, intval) -> s2s "Stmt_Store" >> c2s ' ' >> c2s '(' >> showEndian endian  >> s2s ", " >>  showGlobalIdent globalident  >> s2s ", " >>  showExpr expr0  >> s2s ", " >>  showExpr expr  >> s2s ", " >>  showIntVal intval >> c2s ')'
  |    AbsBasilIR.Stmt_DirectCall (lvars, procident, exprs) -> s2s "Stmt_DirectCall" >> c2s ' ' >> c2s '(' >> showLVars lvars  >> s2s ", " >>  showProcIdent procident  >> s2s ", " >>  showList showExpr exprs >> c2s ')'
  |    AbsBasilIR.Stmt_IndirectCall expr -> s2s "Stmt_IndirectCall" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'
  |    AbsBasilIR.Stmt_Assume (expr, attribset) -> s2s "Stmt_Assume" >> c2s ' ' >> c2s '(' >> showExpr expr  >> s2s ", " >>  showAttribSet attribset >> c2s ')'
  |    AbsBasilIR.Stmt_Guard (expr, attribset) -> s2s "Stmt_Guard" >> c2s ' ' >> c2s '(' >> showExpr expr  >> s2s ", " >>  showAttribSet attribset >> c2s ')'
  |    AbsBasilIR.Stmt_Assert (expr, attribset) -> s2s "Stmt_Assert" >> c2s ' ' >> c2s '(' >> showExpr expr  >> s2s ", " >>  showAttribSet attribset >> c2s ')'


and showLocalVar (e : AbsBasilIR.localVar) : showable = match e with
       AbsBasilIR.LocalVar1 (localident, type') -> s2s "LocalVar1" >> c2s ' ' >> c2s '(' >> showLocalIdent localident  >> s2s ", " >>  showTypeT type' >> c2s ')'


and showGlobalVar (e : AbsBasilIR.globalVar) : showable = match e with
       AbsBasilIR.GlobalVar1 (globalident, type') -> s2s "GlobalVar1" >> c2s ' ' >> c2s '(' >> showGlobalIdent globalident  >> s2s ", " >>  showTypeT type' >> c2s ')'


and showLVars (e : AbsBasilIR.lVars) : showable = match e with
       AbsBasilIR.LVars_Empty  -> s2s "LVars_Empty"
  |    AbsBasilIR.LVars_LocalList localvars -> s2s "LVars_LocalList" >> c2s ' ' >> c2s '(' >> showList showLocalVar localvars >> c2s ')'
  |    AbsBasilIR.LVars_List lvars -> s2s "LVars_List" >> c2s ' ' >> c2s '(' >> showList showLVar lvars >> c2s ')'


and showJump (e : AbsBasilIR.jump) : showable = match e with
       AbsBasilIR.Jump_GoTo blockidents -> s2s "Jump_GoTo" >> c2s ' ' >> c2s '(' >> showList showBlockIdent blockidents >> c2s ')'
  |    AbsBasilIR.Jump_Unreachable  -> s2s "Jump_Unreachable"
  |    AbsBasilIR.Jump_Return exprs -> s2s "Jump_Return" >> c2s ' ' >> c2s '(' >> showList showExpr exprs >> c2s ')'


and showLVar (e : AbsBasilIR.lVar) : showable = match e with
       AbsBasilIR.LVar_Local localvar -> s2s "LVar_Local" >> c2s ' ' >> c2s '(' >> showLocalVar localvar >> c2s ')'
  |    AbsBasilIR.LVar_Global globalvar -> s2s "LVar_Global" >> c2s ' ' >> c2s '(' >> showGlobalVar globalvar >> c2s ')'


and showBlock (e : AbsBasilIR.block) : showable = match e with
       AbsBasilIR.Block1 (blockident, attribset, beginlist, stmts, jump, endlist) -> s2s "Block1" >> c2s ' ' >> c2s '(' >> showBlockIdent blockident  >> s2s ", " >>  showAttribSet attribset  >> s2s ", " >>  showBeginList beginlist  >> s2s ", " >>  showList showStmt stmts  >> s2s ", " >>  showJump jump  >> s2s ", " >>  showEndList endlist >> c2s ')'


and showAttrKeyValue (e : AbsBasilIR.attrKeyValue) : showable = match e with
       AbsBasilIR.AttrKeyValue1 (bident, attr) -> s2s "AttrKeyValue1" >> c2s ' ' >> c2s '(' >> showBIdent bident  >> s2s ", " >>  showAttr attr >> c2s ')'


and showAttribSet (e : AbsBasilIR.attribSet) : showable = match e with
       AbsBasilIR.AttribSet_Some (beginrec, attrkeyvalues, semicolons, endrec) -> s2s "AttribSet_Some" >> c2s ' ' >> c2s '(' >> showBeginRec beginrec  >> s2s ", " >>  showList showAttrKeyValue attrkeyvalues  >> s2s ", " >>  showSemicolons semicolons  >> s2s ", " >>  showEndRec endrec >> c2s ')'
  |    AbsBasilIR.AttribSet_Empty  -> s2s "AttribSet_Empty"


and showAttr (e : AbsBasilIR.attr) : showable = match e with
       AbsBasilIR.Attr_Map (beginrec, attrkeyvalues, semicolons, endrec) -> s2s "Attr_Map" >> c2s ' ' >> c2s '(' >> showBeginRec beginrec  >> s2s ", " >>  showList showAttrKeyValue attrkeyvalues  >> s2s ", " >>  showSemicolons semicolons  >> s2s ", " >>  showEndRec endrec >> c2s ')'
  |    AbsBasilIR.Attr_List (beginlist, attrs, endlist) -> s2s "Attr_List" >> c2s ' ' >> c2s '(' >> showBeginList beginlist  >> s2s ", " >>  showList showAttr attrs  >> s2s ", " >>  showEndList endlist >> c2s ')'
  |    AbsBasilIR.Attr_Lit value -> s2s "Attr_Lit" >> c2s ' ' >> c2s '(' >> showValue value >> c2s ')'
  |    AbsBasilIR.Attr_Str str -> s2s "Attr_Str" >> c2s ' ' >> c2s '(' >> showStr str >> c2s ')'


and showParams (e : AbsBasilIR.params) : showable = match e with
       AbsBasilIR.Params1 (localident, type') -> s2s "Params1" >> c2s ' ' >> c2s '(' >> showLocalIdent localident  >> s2s ", " >>  showTypeT type' >> c2s ')'


and showValue (e : AbsBasilIR.value) : showable = match e with
       AbsBasilIR.Value_BV bvval -> s2s "Value_BV" >> c2s ' ' >> c2s '(' >> showBVVal bvval >> c2s ')'
  |    AbsBasilIR.Value_Int intval -> s2s "Value_Int" >> c2s ' ' >> c2s '(' >> showIntVal intval >> c2s ')'
  |    AbsBasilIR.Value_True  -> s2s "Value_True"
  |    AbsBasilIR.Value_False  -> s2s "Value_False"


and showExpr (e : AbsBasilIR.expr) : showable = match e with
       AbsBasilIR.Expr_Literal value -> s2s "Expr_Literal" >> c2s ' ' >> c2s '(' >> showValue value >> c2s ')'
  |    AbsBasilIR.Expr_Local localvar -> s2s "Expr_Local" >> c2s ' ' >> c2s '(' >> showLocalVar localvar >> c2s ')'
  |    AbsBasilIR.Expr_Global globalvar -> s2s "Expr_Global" >> c2s ' ' >> c2s '(' >> showGlobalVar globalvar >> c2s ')'
  |    AbsBasilIR.Expr_Forall lambdadef -> s2s "Expr_Forall" >> c2s ' ' >> c2s '(' >> showLambdaDef lambdadef >> c2s ')'
  |    AbsBasilIR.Expr_Exists lambdadef -> s2s "Expr_Exists" >> c2s ' ' >> c2s '(' >> showLambdaDef lambdadef >> c2s ')'
  |    AbsBasilIR.Expr_Old expr -> s2s "Expr_Old" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'
  |    AbsBasilIR.Expr_FunctionOp (globalident, exprs) -> s2s "Expr_FunctionOp" >> c2s ' ' >> c2s '(' >> showGlobalIdent globalident  >> s2s ", " >>  showList showExpr exprs >> c2s ')'
  |    AbsBasilIR.Expr_Binary (binop, expr0, expr) -> s2s "Expr_Binary" >> c2s ' ' >> c2s '(' >> showBinOp binop  >> s2s ", " >>  showExpr expr0  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.Expr_Unary (unop, expr) -> s2s "Expr_Unary" >> c2s ' ' >> c2s '(' >> showUnOp unop  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.Expr_ZeroExtend (intval, expr) -> s2s "Expr_ZeroExtend" >> c2s ' ' >> c2s '(' >> showIntVal intval  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.Expr_SignExtend (intval, expr) -> s2s "Expr_SignExtend" >> c2s ' ' >> c2s '(' >> showIntVal intval  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.Expr_Extract (intval0, intval, expr) -> s2s "Expr_Extract" >> c2s ' ' >> c2s '(' >> showIntVal intval0  >> s2s ", " >>  showIntVal intval  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.Expr_Concat (expr0, expr) -> s2s "Expr_Concat" >> c2s ' ' >> c2s '(' >> showExpr expr0  >> s2s ", " >>  showExpr expr >> c2s ')'


and showLambdaDef (e : AbsBasilIR.lambdaDef) : showable = match e with
       AbsBasilIR.LambdaDef1 (localvars, lambdasep, expr) -> s2s "LambdaDef1" >> c2s ' ' >> c2s '(' >> showList showLocalVar localvars  >> s2s ", " >>  showLambdaSep lambdasep  >> s2s ", " >>  showExpr expr >> c2s ')'


and showBinOp (e : AbsBasilIR.binOp) : showable = match e with
       AbsBasilIR.BinOpBVBinOp bvbinop -> s2s "BinOpBVBinOp" >> c2s ' ' >> c2s '(' >> showBVBinOp bvbinop >> c2s ')'
  |    AbsBasilIR.BinOpBVLogicalBinOp bvlogicalbinop -> s2s "BinOpBVLogicalBinOp" >> c2s ' ' >> c2s '(' >> showBVLogicalBinOp bvlogicalbinop >> c2s ')'
  |    AbsBasilIR.BinOpBoolBinOp boolbinop -> s2s "BinOpBoolBinOp" >> c2s ' ' >> c2s '(' >> showBoolBinOp boolbinop >> c2s ')'
  |    AbsBasilIR.BinOpIntLogicalBinOp intlogicalbinop -> s2s "BinOpIntLogicalBinOp" >> c2s ' ' >> c2s '(' >> showIntLogicalBinOp intlogicalbinop >> c2s ')'
  |    AbsBasilIR.BinOpIntBinOp intbinop -> s2s "BinOpIntBinOp" >> c2s ' ' >> c2s '(' >> showIntBinOp intbinop >> c2s ')'
  |    AbsBasilIR.BinOpEqOp eqop -> s2s "BinOpEqOp" >> c2s ' ' >> c2s '(' >> showEqOp eqop >> c2s ')'


and showUnOp (e : AbsBasilIR.unOp) : showable = match e with
       AbsBasilIR.UnOpBVUnOp bvunop -> s2s "UnOpBVUnOp" >> c2s ' ' >> c2s '(' >> showBVUnOp bvunop >> c2s ')'
  |    AbsBasilIR.UnOp_boolnot  -> s2s "UnOp_boolnot"
  |    AbsBasilIR.UnOp_intneg  -> s2s "UnOp_intneg"
  |    AbsBasilIR.UnOp_booltobv1  -> s2s "UnOp_booltobv1"


and showEqOp (e : AbsBasilIR.eqOp) : showable = match e with
       AbsBasilIR.EqOp_eq  -> s2s "EqOp_eq"
  |    AbsBasilIR.EqOp_neq  -> s2s "EqOp_neq"


and showBVUnOp (e : AbsBasilIR.bVUnOp) : showable = match e with
       AbsBasilIR.BVUnOp_bvnot  -> s2s "BVUnOp_bvnot"
  |    AbsBasilIR.BVUnOp_bvneg  -> s2s "BVUnOp_bvneg"


and showBVBinOp (e : AbsBasilIR.bVBinOp) : showable = match e with
       AbsBasilIR.BVBinOp_bvand  -> s2s "BVBinOp_bvand"
  |    AbsBasilIR.BVBinOp_bvor  -> s2s "BVBinOp_bvor"
  |    AbsBasilIR.BVBinOp_bvadd  -> s2s "BVBinOp_bvadd"
  |    AbsBasilIR.BVBinOp_bvmul  -> s2s "BVBinOp_bvmul"
  |    AbsBasilIR.BVBinOp_bvudiv  -> s2s "BVBinOp_bvudiv"
  |    AbsBasilIR.BVBinOp_bvurem  -> s2s "BVBinOp_bvurem"
  |    AbsBasilIR.BVBinOp_bvshl  -> s2s "BVBinOp_bvshl"
  |    AbsBasilIR.BVBinOp_bvlshr  -> s2s "BVBinOp_bvlshr"
  |    AbsBasilIR.BVBinOp_bvnand  -> s2s "BVBinOp_bvnand"
  |    AbsBasilIR.BVBinOp_bvnor  -> s2s "BVBinOp_bvnor"
  |    AbsBasilIR.BVBinOp_bvxor  -> s2s "BVBinOp_bvxor"
  |    AbsBasilIR.BVBinOp_bvxnor  -> s2s "BVBinOp_bvxnor"
  |    AbsBasilIR.BVBinOp_bvcomp  -> s2s "BVBinOp_bvcomp"
  |    AbsBasilIR.BVBinOp_bvsub  -> s2s "BVBinOp_bvsub"
  |    AbsBasilIR.BVBinOp_bvsdiv  -> s2s "BVBinOp_bvsdiv"
  |    AbsBasilIR.BVBinOp_bvsrem  -> s2s "BVBinOp_bvsrem"
  |    AbsBasilIR.BVBinOp_bvsmod  -> s2s "BVBinOp_bvsmod"
  |    AbsBasilIR.BVBinOp_bvashr  -> s2s "BVBinOp_bvashr"


and showBVLogicalBinOp (e : AbsBasilIR.bVLogicalBinOp) : showable = match e with
       AbsBasilIR.BVLogicalBinOp_bvule  -> s2s "BVLogicalBinOp_bvule"
  |    AbsBasilIR.BVLogicalBinOp_bvugt  -> s2s "BVLogicalBinOp_bvugt"
  |    AbsBasilIR.BVLogicalBinOp_bvuge  -> s2s "BVLogicalBinOp_bvuge"
  |    AbsBasilIR.BVLogicalBinOp_bvult  -> s2s "BVLogicalBinOp_bvult"
  |    AbsBasilIR.BVLogicalBinOp_bvslt  -> s2s "BVLogicalBinOp_bvslt"
  |    AbsBasilIR.BVLogicalBinOp_bvsle  -> s2s "BVLogicalBinOp_bvsle"
  |    AbsBasilIR.BVLogicalBinOp_bvsgt  -> s2s "BVLogicalBinOp_bvsgt"
  |    AbsBasilIR.BVLogicalBinOp_bvsge  -> s2s "BVLogicalBinOp_bvsge"


and showIntBinOp (e : AbsBasilIR.intBinOp) : showable = match e with
       AbsBasilIR.IntBinOp_intadd  -> s2s "IntBinOp_intadd"
  |    AbsBasilIR.IntBinOp_intmul  -> s2s "IntBinOp_intmul"
  |    AbsBasilIR.IntBinOp_intsub  -> s2s "IntBinOp_intsub"
  |    AbsBasilIR.IntBinOp_intdiv  -> s2s "IntBinOp_intdiv"
  |    AbsBasilIR.IntBinOp_intmod  -> s2s "IntBinOp_intmod"


and showIntLogicalBinOp (e : AbsBasilIR.intLogicalBinOp) : showable = match e with
       AbsBasilIR.IntLogicalBinOp_intlt  -> s2s "IntLogicalBinOp_intlt"
  |    AbsBasilIR.IntLogicalBinOp_intle  -> s2s "IntLogicalBinOp_intle"
  |    AbsBasilIR.IntLogicalBinOp_intgt  -> s2s "IntLogicalBinOp_intgt"
  |    AbsBasilIR.IntLogicalBinOp_intge  -> s2s "IntLogicalBinOp_intge"


and showBoolBinOp (e : AbsBasilIR.boolBinOp) : showable = match e with
       AbsBasilIR.BoolBinOp_booland  -> s2s "BoolBinOp_booland"
  |    AbsBasilIR.BoolBinOp_boolor  -> s2s "BoolBinOp_boolor"
  |    AbsBasilIR.BoolBinOp_boolimplies  -> s2s "BoolBinOp_boolimplies"


and showRequireTok (e : AbsBasilIR.requireTok) : showable = match e with
       AbsBasilIR.RequireTok_require  -> s2s "RequireTok_require"
  |    AbsBasilIR.RequireTok_requires  -> s2s "RequireTok_requires"


and showEnsureTok (e : AbsBasilIR.ensureTok) : showable = match e with
       AbsBasilIR.EnsureTok_ensure  -> s2s "EnsureTok_ensure"
  |    AbsBasilIR.EnsureTok_ensures  -> s2s "EnsureTok_ensures"


and showFunSpec (e : AbsBasilIR.funSpec) : showable = match e with
       AbsBasilIR.FunSpec_Require (requiretok, expr) -> s2s "FunSpec_Require" >> c2s ' ' >> c2s '(' >> showRequireTok requiretok  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.FunSpec_Ensure (ensuretok, expr) -> s2s "FunSpec_Ensure" >> c2s ' ' >> c2s '(' >> showEnsureTok ensuretok  >> s2s ", " >>  showExpr expr >> c2s ')'
  |    AbsBasilIR.FunSpec_Invariant (blockident, expr) -> s2s "FunSpec_Invariant" >> c2s ' ' >> c2s '(' >> showBlockIdent blockident  >> s2s ", " >>  showExpr expr >> c2s ')'


and showProgSpec (e : AbsBasilIR.progSpec) : showable = match e with
       AbsBasilIR.ProgSpec_Rely expr -> s2s "ProgSpec_Rely" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'
  |    AbsBasilIR.ProgSpec_Guarantee expr -> s2s "ProgSpec_Guarantee" >> c2s ' ' >> c2s '(' >> showExpr expr >> c2s ')'




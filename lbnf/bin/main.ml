(* File generated by the BNF Converter (bnfc 2.9.5). *)

open LBNF
open Lexing
open AbsLBNF

let ident_c = ref 0

let new_wild () =
  ident_c := !ident_c + 1;
  string_of_int !ident_c

let rec p_lab = function
  | LabNoP (Id (Ident l)) -> l
  | LabNoP Wild -> "wild" ^ new_wild ()
  | _ -> failwith "no"

let rec cat_to_name = function
  | IdCat (Ident i) -> i
  | ListCat c -> "List" ^ cat_to_name c

let allowEmpty = function MNonempty -> false | MEmpty -> true
let quote s = "'" ^ s ^ "'"

let unquote s =
  match String.split_on_char '\'' s with [ ""; str; "" ] -> str | _ -> s

module StringMap = Map.Make (String)
module StringSet = Set.Make (String)

let tokens = ref StringSet.empty

let name_of_tok s =
  if
    (String.fold_left (fun a c ->
         a && (Char.uppercase_ascii c <> c || Char.lowercase_ascii c <> c)))
      true s
    && String.length s <> 0
  then String.uppercase_ascii s
  else
    match s with
    | "(" -> "OPAREN"
    | ")" -> "CPAREN"
    | "]" -> "CBRACKET"
    | "[" -> "OBRACKET"
    | "}" -> "CBRACE"
    | "{" -> "OBRACE"
    | "->" -> "RARROW"
    | "<-" -> "LARROW"
    | "=" -> "EQS"
    | "==" -> "EQUALS"
    | "===" -> "TRIPLEEQUALS"
    | "," -> "COMMA"
    | ";" -> "SCOLON"
    | ":" -> "COLON"
    | ":=" -> "WALRUS"
    | "" -> "EPS"
    | _ -> "TOK" ^ string_of_int @@ (String.hash s mod 1024)

let rec item_name = function
  | Terminal t ->
      tokens := StringSet.add t !tokens;
      name_of_tok t
  | NTerminal c -> cat_to_name c

let p_tokens () =
  StringSet.to_list !tokens
  |> List.map (function s ->
         Printf.sprintf "%s : %s ; " (name_of_tok s) (quote s))
  |> String.concat " \n"

let rec reg_to_regex = function
  | RSeq (RChar i, RChar j) -> Printf.sprintf "'%c%c'" i j
  | RSeq (i, j) -> reg_to_regex i ^ reg_to_regex j
  | RAlt (i, j) -> "(" ^ reg_to_regex i ^ "|" ^ reg_to_regex j ^ ")"
  | RStar i -> reg_to_regex i ^ "*"
  | RPlus i -> reg_to_regex i ^ "+"
  | RChar c -> "'" ^ String.make 1 c ^ "'"
  | RDigit -> "[0-9]"
  | RLetter -> "[a-zA-Z]"
  | RUpper -> "[A-Z]"
  | RLower -> "[a-z]"
  | REps -> ""
  | RAny -> "."
  | RMinus (i, j) -> reg_to_regex i ^ "-" ^ reg_to_regex j
  | ROpt i -> "(" ^ reg_to_regex i ^ ")?"
  | RAlts i -> "[" ^ i ^ "]"
  | RSeqs i -> "'" ^ i ^ "'"

let to_antlr (g : AbsLBNF.grammar) =
  let g = match g with MkGrammar x -> x in
  let tokens =
    List.filter_map
      (function
        | Token (i, r) -> Some (i, r)
        | PosToken (i, r) -> Some (i, r)
        | _ -> None)
      g
  in

  let tokens =
    List.map (function Ident i, r -> i ^ " : " ^ reg_to_regex r) tokens
  in

  let list_with_term =
    List.filter_map
      (function
        | Terminator (minsize, cat, str) ->
            Some (allowEmpty minsize, cat_to_name cat, str)
        | _ -> None)
      g
  in
  let list_with_sep =
    List.filter_map
      (function
        | Separator (minsize, cat, str) ->
            Some (allowEmpty minsize, cat_to_name cat, str)
        | _ -> None)
      g
  in
  let non_empty =
    List.filter_map
      (function true, c, _ -> Some c | _ -> None)
      (list_with_term @ list_with_sep)
    |> StringSet.of_list
  in
  let g =
    List.concat_map
      (function
        | Rule (l, cat, items) ->
            [
              (cat_to_name cat, p_lab l, List.map (fun s -> item_name s) items);
            ]
        | Rules (Ident l, rhs) ->
            let rhs =
              List.map
                (function MkRHS i -> List.map (fun s -> item_name s) i)
                rhs
            in
            let labs =
              List.mapi
                (fun ind v ->
                  match v with
                  | h :: [] -> String.lowercase_ascii (unquote h)
                  | _ -> l ^ "rule_" ^ string_of_int ind)
                rhs
            in
            List.combine labs rhs |> List.map (fun i -> (l, fst i, snd i))
        | _ -> [])
      g
  in
  let prods =
    List.map (function c, _, _ -> c) g |> List.sort_uniq String.compare
  in

  let prods =
    List.map
      (function
        | p ->
            let rules =
              List.filter_map
                (function
                  | c, lab, prod when c = p ->
                      Some (Printf.sprintf "%s" (String.concat " " prod))
                  | _ -> None)
                g
            in
            let rules = String.concat "\n    | " rules in
            Printf.sprintf "%s : %s\n    ;" p rules)
      prods
  in
  print_endline "---";
  print_string (String.concat ";\n" tokens);
  print_endline ";\n";
  print_endline (p_tokens ());
  print_endline "";
  print_endline (String.concat "\n\n" prods);
  ()

let parse (c : in_channel) : AbsLBNF.grammar =
  let lexbuf = Lexing.from_channel c in
  try ParLBNF.pGrammar LexLBNF.token lexbuf
  with ParLBNF.Error ->
    let start_pos = Lexing.lexeme_start_p lexbuf
    and end_pos = Lexing.lexeme_end_p lexbuf in
    raise (BNFC_Util.Parse_error (start_pos, end_pos))

let showTree (t : AbsLBNF.grammar) : string =
  "[Abstract syntax]\n\n"
  ^ ShowLBNF.show (ShowLBNF.showGrammar t)
  ^ "\n\n" ^ "[Linearized tree]\n\n"
  ^ PrintLBNF.printTree PrintLBNF.prtGrammar t
  ^ "\n"

let main () =
  let channel =
    if Array.length Sys.argv > 1 then open_in Sys.argv.(1) else stdin
  in
  let r =
    try parse channel
    with BNFC_Util.Parse_error (start_pos, end_pos) ->
      Printf.printf "Parse error at %d.%d-%d.%d\n" start_pos.pos_lnum
        (start_pos.pos_cnum - start_pos.pos_bol + 1)
        end_pos.pos_lnum
        (end_pos.pos_cnum - end_pos.pos_bol + 1);
      exit 1
  in
  print_string (showTree r);
  print_endline "\n";
  to_antlr r
;;

main ()

(* File generated by the BNF Converter (bnfc 2.9.5). *)

(* pretty-printer *)

open Printf

(* We use string buffers for efficient string concatenation.
   A document takes a buffer and an indentation, has side effects on the buffer
   and returns a new indentation. The indentation argument indicates the level
   of indentation to be used if a new line has to be started (because of what is
   already in the buffer) *)
type doc = Buffer.t -> int -> int

let rec printTree (printer : int -> 'a -> doc) (tree : 'a) : string =
    let buffer_init_size = 64 (* you may want to change this *)
    in let buffer = Buffer.create buffer_init_size
    in
        let _ = printer 0 tree buffer 0 in (* discard return value *)
        Buffer.contents buffer

let indent_width = 2

let spaces (i: int) : string = if i > 0 then String.make i ' ' else ""
let indent (i: int) : string = "\n" ^ spaces i

(* To avoid dependency on package extlib, which has
   Extlib.ExtChar.Char.is_whitespace, we employ the following awkward
   way to check a character for whitespace.
   Note: String.trim exists in the core libraries since Ocaml 4.00. *)
let isWhiteSpace (c: char) : bool = String.trim (String.make 1 c) = ""

(* this render function is written for C-style languages, you may want to change it *)
let render (s : string) : doc = fun buf i ->
    (* invariant: last char of the buffer is never whitespace *)
    let n = Buffer.length buf in
    let last = if n = 0 then None else Some (Buffer.nth buf (n-1)) in
    let newindent = match s with
        "{" -> i + indent_width
      | "}" -> i - indent_width
      | _ -> i in
    let whitespace = match last with
        None -> ""
      | Some '}' -> (match s with
            ";" -> ""
          | _ -> indent newindent)
      | (Some '{') | (Some ';') -> if s = "}" then indent newindent else indent i
      | (Some '[') | (Some '(') -> ""
      | Some c -> if isWhiteSpace c then "" else (match s with
             ";" | "," | ")" | "]" -> ""
           | "{" -> indent i
           | "}" -> indent newindent
           | _ -> if String.trim s = "" then "" else " ") in
    Buffer.add_string buf whitespace;
    Buffer.add_string buf s;
    newindent

let emptyDoc : doc = fun buf i -> i

let concatD (ds : doc list) : doc = fun buf i ->
    List.fold_left (fun accIndent elemDoc -> elemDoc buf accIndent) (emptyDoc buf i) ds

let parenth (d:doc) : doc = concatD [render "("; d; render ")"]

let prPrec (i:int) (j:int) (d:doc) : doc = if j<i then parenth d else d


let prtChar (_:int) (c:char) : doc = render ("'" ^ Char.escaped c ^ "'")



let prtInt (_:int) (i:int) : doc = render (string_of_int i)
let rec prtIntListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtInt 0 x])
  | (_,x::xs) -> (concatD [prtInt 0 x ; render "," ; prtIntListBNFC 0 xs])


let prtFloat (_:int) (f:float) : doc = render (sprintf "%.15g" f)



let prtString (_:int) (s:string) : doc = render ("\"" ^ String.escaped s ^ "\"")
let rec prtStringListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtString 0 x])
  | (_,x::xs) -> (concatD [prtString 0 x ; render "," ; prtStringListBNFC 0 xs])


let prtIdent _ (AbsLBNF.Ident i) : doc = render i
let rec prtIdentListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtIdent 0 x])
  | (_,x::xs) -> (concatD [prtIdent 0 x ; render "," ; prtIdentListBNFC 0 xs])


let rec prtGrammar (i:int) (e : AbsLBNF.grammar) : doc = match e with
       AbsLBNF.MkGrammar defs -> prPrec i 0 (concatD [prtDefListBNFC 0 defs])


and prtDef (i:int) (e : AbsLBNF.def) : doc = match e with
       AbsLBNF.Rule (label, cat, items) -> prPrec i 0 (concatD [prtLabel 0 label ; render "." ; prtCat 0 cat ; render "::=" ; prtItemListBNFC 0 items])
  |    AbsLBNF.Comment string -> prPrec i 0 (concatD [render "comment" ; prtString 0 string])
  |    AbsLBNF.Comments (string1, string2) -> prPrec i 0 (concatD [render "comment" ; prtString 0 string1 ; prtString 0 string2])
  |    AbsLBNF.Internal (label, cat, items) -> prPrec i 0 (concatD [render "internal" ; prtLabel 0 label ; render "." ; prtCat 0 cat ; render "::=" ; prtItemListBNFC 0 items])
  |    AbsLBNF.Token (ident, reg) -> prPrec i 0 (concatD [render "token" ; prtIdent 0 ident ; prtReg 0 reg])
  |    AbsLBNF.PosToken (ident, reg) -> prPrec i 0 (concatD [render "position" ; render "token" ; prtIdent 0 ident ; prtReg 0 reg])
  |    AbsLBNF.Entryp idents -> prPrec i 0 (concatD [render "entrypoints" ; prtIdentListBNFC 0 idents])
  |    AbsLBNF.Separator (minimumsize, cat, string) -> prPrec i 0 (concatD [render "separator" ; prtMinimumSize 0 minimumsize ; prtCat 0 cat ; prtString 0 string])
  |    AbsLBNF.Terminator (minimumsize, cat, string) -> prPrec i 0 (concatD [render "terminator" ; prtMinimumSize 0 minimumsize ; prtCat 0 cat ; prtString 0 string])
  |    AbsLBNF.Coercions (ident, integer) -> prPrec i 0 (concatD [render "coercions" ; prtIdent 0 ident ; prtInt 0 integer])
  |    AbsLBNF.Rules (ident, rhss) -> prPrec i 0 (concatD [render "rules" ; prtIdent 0 ident ; render "::=" ; prtRHSListBNFC 0 rhss])
  |    AbsLBNF.Layout strings -> prPrec i 0 (concatD [render "layout" ; prtStringListBNFC 0 strings])
  |    AbsLBNF.LayoutStop strings -> prPrec i 0 (concatD [render "layout" ; render "stop" ; prtStringListBNFC 0 strings])
  |    AbsLBNF.LayoutTop  -> prPrec i 0 (concatD [render "layout" ; render "toplevel"])

and prtDefListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtDef 0 x ; render ";" ; prtDefListBNFC 0 xs])
and prtItem (i:int) (e : AbsLBNF.item) : doc = match e with
       AbsLBNF.Terminal string -> prPrec i 0 (concatD [prtString 0 string])
  |    AbsLBNF.NTerminal cat -> prPrec i 0 (concatD [prtCat 0 cat])

and prtItemListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,x::xs) -> (concatD [prtItem 0 x ; prtItemListBNFC 0 xs])
and prtCat (i:int) (e : AbsLBNF.cat) : doc = match e with
       AbsLBNF.ListCat cat -> prPrec i 0 (concatD [render "[" ; prtCat 0 cat ; render "]"])
  |    AbsLBNF.IdCat ident -> prPrec i 0 (concatD [prtIdent 0 ident])


and prtLabel (i:int) (e : AbsLBNF.label) : doc = match e with
       AbsLBNF.LabNoP labelid -> prPrec i 0 (concatD [prtLabelId 0 labelid])
  |    AbsLBNF.LabP (labelid, profitems) -> prPrec i 0 (concatD [prtLabelId 0 labelid ; prtProfItemListBNFC 0 profitems])
  |    AbsLBNF.LabPF (labelid1, labelid2, profitems) -> prPrec i 0 (concatD [prtLabelId 0 labelid1 ; prtLabelId 0 labelid2 ; prtProfItemListBNFC 0 profitems])
  |    AbsLBNF.LabF (labelid1, labelid2) -> prPrec i 0 (concatD [prtLabelId 0 labelid1 ; prtLabelId 0 labelid2])


and prtLabelId (i:int) (e : AbsLBNF.labelId) : doc = match e with
       AbsLBNF.Id ident -> prPrec i 0 (concatD [prtIdent 0 ident])
  |    AbsLBNF.Wild  -> prPrec i 0 (concatD [render "_"])
  |    AbsLBNF.ListE  -> prPrec i 0 (concatD [render "[" ; render "]"])
  |    AbsLBNF.ListCons  -> prPrec i 0 (concatD [render "(" ; render ":" ; render ")"])
  |    AbsLBNF.ListOne  -> prPrec i 0 (concatD [render "(" ; render ":" ; render "[" ; render "]" ; render ")"])


and prtProfItem (i:int) (e : AbsLBNF.profItem) : doc = match e with
       AbsLBNF.ProfIt (intlists, integers) -> prPrec i 0 (concatD [render "(" ; render "[" ; prtIntListListBNFC 0 intlists ; render "]" ; render "," ; render "[" ; prtIntListBNFC 0 integers ; render "]" ; render ")"])

and prtProfItemListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtProfItem 0 x])
  | (_,x::xs) -> (concatD [prtProfItem 0 x ; prtProfItemListBNFC 0 xs])
and prtIntList (i:int) (e : AbsLBNF.intList) : doc = match e with
       AbsLBNF.Ints integers -> prPrec i 0 (concatD [render "[" ; prtIntListBNFC 0 integers ; render "]"])

and prtIntListListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtIntList 0 x])
  | (_,x::xs) -> (concatD [prtIntList 0 x ; render "," ; prtIntListListBNFC 0 xs])
and prtRHS (i:int) (e : AbsLBNF.rHS) : doc = match e with
       AbsLBNF.MkRHS items -> prPrec i 0 (concatD [prtItemListBNFC 0 items])

and prtRHSListBNFC i es : doc = match (i, es) with
    (_,[]) -> (concatD [])
  | (_,[x]) -> (concatD [prtRHS 0 x])
  | (_,x::xs) -> (concatD [prtRHS 0 x ; render "|" ; prtRHSListBNFC 0 xs])
and prtMinimumSize (i:int) (e : AbsLBNF.minimumSize) : doc = match e with
       AbsLBNF.MNonempty  -> prPrec i 0 (concatD [render "nonempty"])
  |    AbsLBNF.MEmpty  -> prPrec i 0 (concatD [])


and prtReg (i:int) (e : AbsLBNF.reg) : doc = match e with
       AbsLBNF.RSeq (reg1, reg2) -> prPrec i 2 (concatD [prtReg 2 reg1 ; prtReg 3 reg2])
  |    AbsLBNF.RAlt (reg1, reg2) -> prPrec i 1 (concatD [prtReg 1 reg1 ; render "|" ; prtReg 2 reg2])
  |    AbsLBNF.RMinus (reg1, reg2) -> prPrec i 1 (concatD [prtReg 2 reg1 ; render "-" ; prtReg 2 reg2])
  |    AbsLBNF.RStar reg -> prPrec i 3 (concatD [prtReg 3 reg ; render "*"])
  |    AbsLBNF.RPlus reg -> prPrec i 3 (concatD [prtReg 3 reg ; render "+"])
  |    AbsLBNF.ROpt reg -> prPrec i 3 (concatD [prtReg 3 reg ; render "?"])
  |    AbsLBNF.REps  -> prPrec i 3 (concatD [render "eps"])
  |    AbsLBNF.RChar char -> prPrec i 3 (concatD [prtChar 0 char])
  |    AbsLBNF.RAlts string -> prPrec i 3 (concatD [render "[" ; prtString 0 string ; render "]"])
  |    AbsLBNF.RSeqs string -> prPrec i 3 (concatD [render "{" ; prtString 0 string ; render "}"])
  |    AbsLBNF.RDigit  -> prPrec i 3 (concatD [render "digit"])
  |    AbsLBNF.RLetter  -> prPrec i 3 (concatD [render "letter"])
  |    AbsLBNF.RUpper  -> prPrec i 3 (concatD [render "upper"])
  |    AbsLBNF.RLower  -> prPrec i 3 (concatD [render "lower"])
  |    AbsLBNF.RAny  -> prPrec i 3 (concatD [render "char"])




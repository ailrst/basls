/* File generated by the BNF Converter (bnfc 2.9.5). */

/* Parser definition for use with menhir */

%{
open AbsLBNF
open Lexing
%}

%token KW_comment KW_internal KW_token KW_position KW_entrypoints KW_separator KW_terminator KW_coercions KW_rules KW_layout KW_stop KW_toplevel KW_nonempty KW_eps KW_digit KW_letter KW_upper KW_lower KW_char

%token SYMB1 /* ; */
%token SYMB2 /* . */
%token SYMB3 /* ::= */
%token SYMB4 /* [ */
%token SYMB5 /* ] */
%token SYMB6 /* _ */
%token SYMB7 /* ( */
%token SYMB8 /* : */
%token SYMB9 /* ) */
%token SYMB10 /* , */
%token SYMB11 /* | */
%token SYMB12 /* - */
%token SYMB13 /* * */
%token SYMB14 /* + */
%token SYMB15 /* ? */
%token SYMB16 /* { */
%token SYMB17 /* } */

%token TOK_EOF
%token <string> TOK_Ident
%token <char>   TOK_Char
%token <float>  TOK_Double
%token <int>    TOK_Integer
%token <string> TOK_String

%start pGrammar pDef_list pItem_list pDef pItem pCat pLabel pLabelId pProfItem pIntList pInt_list pIntList_list pProfItem_list pString_list pRHS_list pRHS pMinimumSize pReg2 pReg1 pReg3 pReg pIdent_list
%type <AbsLBNF.grammar> pGrammar
%type <AbsLBNF.def list> pDef_list
%type <AbsLBNF.item list> pItem_list
%type <AbsLBNF.def> pDef
%type <AbsLBNF.item> pItem
%type <AbsLBNF.cat> pCat
%type <AbsLBNF.label> pLabel
%type <AbsLBNF.labelId> pLabelId
%type <AbsLBNF.profItem> pProfItem
%type <AbsLBNF.intList> pIntList
%type <int list> pInt_list
%type <AbsLBNF.intList list> pIntList_list
%type <AbsLBNF.profItem list> pProfItem_list
%type <string list> pString_list
%type <AbsLBNF.rHS list> pRHS_list
%type <AbsLBNF.rHS> pRHS
%type <AbsLBNF.minimumSize> pMinimumSize
%type <AbsLBNF.reg> pReg2
%type <AbsLBNF.reg> pReg1
%type <AbsLBNF.reg> pReg3
%type <AbsLBNF.reg> pReg
%type <AbsLBNF.ident list> pIdent_list

%type <AbsLBNF.grammar> grammar
%type <AbsLBNF.def list> def_list
%type <AbsLBNF.item list> item_list
%type <AbsLBNF.def> def
%type <AbsLBNF.item> item
%type <AbsLBNF.cat> cat
%type <AbsLBNF.label> label
%type <AbsLBNF.labelId> labelId
%type <AbsLBNF.profItem> profItem
%type <AbsLBNF.intList> intList
%type <int list> int_list
%type <AbsLBNF.intList list> intList_list
%type <AbsLBNF.profItem list> profItem_list
%type <string list> string_list
%type <AbsLBNF.rHS list> rHS_list
%type <AbsLBNF.rHS> rHS
%type <AbsLBNF.minimumSize> minimumSize
%type <AbsLBNF.reg> reg2
%type <AbsLBNF.reg> reg1
%type <AbsLBNF.reg> reg3
%type <AbsLBNF.reg> reg
%type <AbsLBNF.ident list> ident_list

%type <AbsLBNF.ident> ident
%type <char> char
%type <int> int
%type <string> string

%%

pGrammar : grammar TOK_EOF { $1 };

pDef_list : def_list TOK_EOF { $1 };

pItem_list : item_list TOK_EOF { $1 };

pDef : def TOK_EOF { $1 };

pItem : item TOK_EOF { $1 };

pCat : cat TOK_EOF { $1 };

pLabel : label TOK_EOF { $1 };

pLabelId : labelId TOK_EOF { $1 };

pProfItem : profItem TOK_EOF { $1 };

pIntList : intList TOK_EOF { $1 };

pInt_list : int_list TOK_EOF { $1 };

pIntList_list : intList_list TOK_EOF { $1 };

pProfItem_list : profItem_list TOK_EOF { $1 };

pString_list : string_list TOK_EOF { $1 };

pRHS_list : rHS_list TOK_EOF { $1 };

pRHS : rHS TOK_EOF { $1 };

pMinimumSize : minimumSize TOK_EOF { $1 };

pReg2 : reg2 TOK_EOF { $1 };

pReg1 : reg1 TOK_EOF { $1 };

pReg3 : reg3 TOK_EOF { $1 };

pReg : reg TOK_EOF { $1 };

pIdent_list : ident_list TOK_EOF { $1 };

grammar : def_list { MkGrammar $1 }
  ;

def_list : /* empty */ { []  }
  | def SYMB1 def_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

item_list : /* empty */ { []  }
  | item item_list { (fun (x,xs) -> x::xs) ($1, $2) }
  ;

def : label SYMB2 cat SYMB3 item_list { Rule ($1, $3, $5) }
  | KW_comment string { Comment $2 }
  | KW_comment string string { Comments ($2, $3) }
  | KW_internal label SYMB2 cat SYMB3 item_list { Internal ($2, $4, $6) }
  | KW_token ident reg { Token ($2, $3) }
  | KW_position KW_token ident reg { PosToken ($3, $4) }
  | KW_entrypoints ident_list { Entryp $2 }
  | KW_separator minimumSize cat string { Separator ($2, $3, $4) }
  | KW_terminator minimumSize cat string { Terminator ($2, $3, $4) }
  | KW_coercions ident int { Coercions ($2, $3) }
  | KW_rules ident SYMB3 rHS_list { Rules ($2, $4) }
  | KW_layout string_list { Layout $2 }
  | KW_layout KW_stop string_list { LayoutStop $3 }
  | KW_layout KW_toplevel { LayoutTop  }
  ;

item : string { Terminal $1 }
  | cat { NTerminal $1 }
  ;

cat : SYMB4 cat SYMB5 { ListCat $2 }
  | ident { IdCat $1 }
  ;

label : labelId { LabNoP $1 }
  | labelId profItem_list { LabP ($1, $2) }
  | labelId labelId profItem_list { LabPF ($1, $2, $3) }
  | labelId labelId { LabF ($1, $2) }
  ;

labelId : ident { Id $1 }
  | SYMB6 { Wild  }
  | SYMB4 SYMB5 { ListE  }
  | SYMB7 SYMB8 SYMB9 { ListCons  }
  | SYMB7 SYMB8 SYMB4 SYMB5 SYMB9 { ListOne  }
  ;

profItem : SYMB7 SYMB4 intList_list SYMB5 SYMB10 SYMB4 int_list SYMB5 SYMB9 { ProfIt ($3, $7) }
  ;

intList : SYMB4 int_list SYMB5 { Ints $2 }
  ;

int_list : /* empty */ { []  }
  | int { (fun x -> [x]) $1 }
  | int SYMB10 int_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

intList_list : /* empty */ { []  }
  | intList { (fun x -> [x]) $1 }
  | intList SYMB10 intList_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

profItem_list : profItem { (fun x -> [x]) $1 }
  | profItem profItem_list { (fun (x,xs) -> x::xs) ($1, $2) }
  ;

string_list : string { (fun x -> [x]) $1 }
  | string SYMB10 string_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

rHS_list : rHS { (fun x -> [x]) $1 }
  | rHS SYMB11 rHS_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

rHS : item_list { MkRHS $1 }
  ;

minimumSize : KW_nonempty { MNonempty  }
  | /* empty */ { MEmpty  }
  ;

reg2 : reg2 reg3 { RSeq ($1, $2) }
  | reg3 {  $1 }
  ;

reg1 : reg1 SYMB11 reg2 { RAlt ($1, $3) }
  | reg2 SYMB12 reg2 { RMinus ($1, $3) }
  | reg2 {  $1 }
  ;

reg3 : reg3 SYMB13 { RStar $1 }
  | reg3 SYMB14 { RPlus $1 }
  | reg3 SYMB15 { ROpt $1 }
  | KW_eps { REps  }
  | char { RChar $1 }
  | SYMB4 string SYMB5 { RAlts $2 }
  | SYMB16 string SYMB17 { RSeqs $2 }
  | KW_digit { RDigit  }
  | KW_letter { RLetter  }
  | KW_upper { RUpper  }
  | KW_lower { RLower  }
  | KW_char { RAny  }
  | SYMB7 reg SYMB9 {  $2 }
  ;

reg : reg1 {  $1 }
  ;

ident_list : ident { (fun x -> [x]) $1 }
  | ident SYMB10 ident_list { (fun (x,xs) -> x::xs) ($1, $3) }
  ;

ident : TOK_Ident  { Ident $1 };
char : TOK_Char { $1 };
int :  TOK_Integer  { $1 };
string : TOK_String { $1 };

